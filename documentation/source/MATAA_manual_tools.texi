@node MATAA tools reference
@chapter MATAA tools reference

@paragraphindent 0

This section contains a list of the MATAA tools and their usage information as of 02-Jan-2021.

@findex mataa_audio_guess_latency
@node mataa_audio_guess_latency
@section mataa_audio_guess_latency

file: ...mataa_tools/mataa_audio_guess_latency.m@*

function latency = mataa_audio_guess_latency (fs,maxLatency);@*

DESCRIPTION:@*
This function measures the latency of the audio hardware at sampling frequency fs, including the connected DUT.@*

The latency is defined as follows:@*
t1: the time needed by the audio output device to process the signal@*
t2: the time needed by the signal to travel from the audio output to the audio input of the computer (this will be determined by the analytical setup. In case of loudspeaker analysis, t2 will be deteremined mainly by the distance between microphone and loudspeaker).@*
t3: the time needed by the audio input device to process the signal@*

Then: latency = t1 + t2 + t3@*

INPUT:@*
fs: sampling frequency to be used for audio I/O (in seconds)@*
maxLatency (optional): the expected maximum of the latency (in seconds). If not specified, the user will be asked to supply a value.@*

OUTPUT:@*
latency: the latency of the system, as defined above (in seconds)@*


@findex mataa_audio_info
@node mataa_audio_info
@section mataa_audio_info

file: ...mataa_tools/mataa_audio_info.m@*

function audioInfo = mataa_audio_info;@*

DESCRIPTION:@*
This function returns a struct (audioInfo) containing information on the default devices for audio input and output. Note: the list of supported sample rates reflects the 'standard' rates offered by the operating system. This is not necessarily identical to the rates supported by hardware itself, as the operating system may provide other rates, e.g. by (automatic) sample-rate conversion (such as in the case of Mac OS X / CoreAudio). Also, the list of supported sample rates may be incomplete, because the TestDevices programs checks for 'standard' rates only. It may therefore be possible to use other sample rates than those returned from this function (check the description of your audio hardware if you need to know the rates supported by the hardware). This function checks for full and half duplex operation (i.e. if the input and output devices are the same), and returns the list of supported sample rates depending on full or half duplex operation (they may be different, e.g. if a high sampling rate is only available with half duplex due to limits in the data transfer rates).@*

NOTE: some audio interfaces react in unwanted ways to the audio-info query. For instance, the RTX-6001 goes through a nasty cycle of relays clicking, which causes clicks in its audio output and may lead to excessive wear of the relays. To avoid such effects, the test query can be skipped by changing the value of the 'audioinfo_skipcheck' field in the MATAA settings to a non-zero value. mataa_audio_info will then return audioInfo corresponding to a "typical" generic audio interface.@*

EXAMPLE:@*
(get some information on the audio hardware):@*
> info = mataa_audio_info;@*
> info.input      % shows information about the input device@*
> info.output     % shows information about the output device@*

prepare device info (with empty/unknown entries):@*

@findex mataa_audio_playrec_init
@node mataa_audio_playrec_init
@section mataa_audio_playrec_init

file: ...mataa_tools/mataa_audio_playrec_init.m@*

function success = mataa_audio_playrec_init (fs, output_device, input_device, num_output_chan, num_input_chan);@*

DESCRIPTION:@*
Check if PlayRec is initialised with the given sample rate and audio input / output devices, and reset/init PlayRec accordingly if needed.@*

INPUT:@*
fs: sample rate (samples per second)@*
output_device, input_device: device identifiers for PlayRec audio output and input, either a (partial) string label or PlayRec ID numers (string or integer)@*
num_output_chan, num_input_chan: number of input channels needed for audio output and input@*

OUTPUT:@*
success: flag indicating of PlayRec is initialised properly according to the INPUTs (bool)@*

EXAMPLE:@*
> mataa_audio_playrec_init (44100, 'RTX6001', 'RTX6001', 2, 2)@*


@findex mataa_audio_playrec_list_devices
@node mataa_audio_playrec_list_devices
@section mataa_audio_playrec_list_devices

file: ...mataa_tools/mataa_audio_playrec_list_devices.m@*

function [dev_names, dev_IDs] = mataa_audio_playrec_list_devices ();@*

DESCRIPTION:@*
Return IDs and names of all audio devices that are available with PlayRec@*

INPUT:@*
(none)@*

OUTPUT:@*
dev_names: names / labels of the audio devices (cell string)@*
dev_IDs: PlayRec IDs of the audio devices (vector)@*


@findex mataa_cal_autoscale
@node mataa_cal_autoscale
@section mataa_cal_autoscale

file: ...mataa_tools/mataa_cal_autoscale.m@*

function cal = mataa_cal_autoscale (c);@*

DESCRIPTION:@*
Execute the "autoscaling" function(s) for the ADC and DAC device(s) described by the calibration struct c, and return the ADC and DAC sensitivites in cal struct in the same format as with fixed/non-autoscaling calibration structs.@*


@findex mataa_computer
@node mataa_computer
@section mataa_computer

file: ...mataa_tools/mataa_computer.m@*

function platform = mataa_computer;@*

DESCRIPTION:@*
Returns the current computer platform.@*

INPUT:@*
(none)@*

OUTPUT@*
platform: string indicating the computer platform:@*
MAC:      Mac OS X (Darwin)@*
PCWIN:    MS Windows@*
LINUX_X86-32:  Linux on x86 / 32 Bit platform@*
LINUX_X86-64:  Linux on AMD / 64 Bit platform@*
UNKNOWN:  unknown platform (unknown to MATAA)@*


@findex mataa_convolve
@node mataa_convolve
@section mataa_convolve

file: ...mataa_tools/mataa_convolve.m@*

function z = mataa_convolve(x,y);@*

DESCRIPTION:@*
This function convolves two data series x and y. The convolution is done using the fourier-transform method. x and y should have the same length (pad zeroes, if necessary). The result of the convolution (z) will also be of the same length as x and y.@*

see also http://rkb.home.cern.ch/rkb/AN16pp/node38.html@*

EXAMPLE:@*
T = 1; fs = 44100; f0 = 10;@*
t = [1/fs:1/fs:T];@*
x = sin(2*pi*f0*t);@*
y = zeros (size(x));@*
y(1000) = -1.5;@*
z = mataa_convolve (x,y);@*
plot (t,x,'r',t,y,'k',t,z,'b')@*


@findex mataa_deConvolve
@node mataa_deConvolve
@section mataa_deConvolve

file: ...mataa_tools/mataa_deConvolve.m@*

function [y] = mataa_deConvolve(z,x);@*

DESCRIPTION:@*
This function deconvolves z from x. In other words: if z = x*y ('z is the convolution of x and y'), then this function calculates y from z and x. The deconvolution is done using the fourier-transform method. z and x should have the same length (pad zeroes, if necessary).@*

see also http://rkb.home.cern.ch/rkb/AN16pp/node38.html@*

Example (calculate impulse response of a loudspeaker or other DUT):@*
  x: the input signal sent to the speaker (known), length(x) = Lx@*
  y: the impulse response of the speaker (not known), length(y) = Ly@*
  z: the measured response of the speaker to signal x (known), length(z) = Lz@*
 then: z = x*y@*
 note: Lz = Lx + Ly -1@*

then: Z = XY (where the uppercase letters denote the complex fourier transforms of x, y, and z)@*
or: fft(z) = fft(x) fft(y), where x and y are padded with zeros to length Lz@*
hence fft(y) = fft(z) / fft(x), or y = ifft( fft(z) / fft(x) )@*


@findex mataa_export_FRD
@node mataa_export_FRD
@section mataa_export_FRD

file: ...mataa_tools/mataa_export_FRD.m@*

function mataa_export_FRD (f,mag,phase,comment,file);@*

DESCRIPTION:@*
Export frequency-domain data to a FRD file.@*
(see also http://www.pvconsultants.com/audio/frdis.htm)@*
An FRD file is essentially an ASCII file containing three columns of data: frequency, magnitude, and phase. A detailed description of the FRD file format is given below.@*

INPUT:@*
f: frequency values (Hz)@*
mag: magnitude values (usually in dB)@*
phase: phase (in degrees, usually wrapped to the range -180...+180 degrees)@*
file: string containing the name of the file to be written (may contain a complete path. If no path is given, the file will be written to the current working directory)@*
comment: string containing a comment to be saved with the data, e.g. a description of the data. Use comment = '' if you do not want a comment in the data file.@*

OUTPUT:@*
(none)@*

DESCRIPTION OF THE FRD FILE FORMAT@*
The following is a detailed description of the FRD format (taken from the website given above):@*
--------------------------------@*
What is an FRD File?@*

A Frequency Response Data file is a human readable text file that contains a numerical description of Frequency and Phase Response.  The purpose of an FRD file to represent measurements or targets or corrections of acoustic items, like loudspeakers and/or crossovers or room effects. The reason for using FRD files is to pass information between different design programs and thus to get the programs to share data and work together to achieve a complete finished design.@*

Structurally, an FRD file is very simple. An * is placed in the first character position of any line that is a comment, so the remainder of that line is ignored. Comments can only be added at the beginning of an FRD file and not embedded once the data starts.@*

After the comment, the data block is composed of three numerical values per line separated by either one or more spaces or a tab. Each line is a single measurement or value instance. The numerical values, in order, per line, correspond to Frequency, Magnitude and Phase. The frequency data should start at the low end of the response and proceed to the higher end with no directional reversals or overlapping repeating regions in the frequency progression. That is all. It should look something like this:@*

        @*
       * Seas T25-001.frd@*
       * Freq(Hz)  SPL(db)  Phase(deg)@*
       *@*
       10        21.0963   158.4356 @*
       10.1517   21.0967   158.4363 @*
       10.3056   21.3305   158.7836 @*
       10.4619   21.5644   159.1299 @*
       10.6205   21.7983   159.2452 @*
       10.7816   22.032     159.3599 @*
       10.9451   22.2658   159.4099 @*
       11.1111   22.4996   159.4597 @*
       11.2796   22.7335   159.4832 @*
       11.4507   22.9672   159.5065 @*
       11.6243   23.2011   159.5171 @*
       11.8006   23.4349   159.5276 @*
       11.9795   23.6687   159.5308 @*
       12.1612   23.9025   159.534 @*

The comment field mentioned above is sometimes required, even if the data in it is never used, or at least we have encountered programs that will not load the FRD file if the Comment field is not there. We have also found the opposite, programs that get confused about the comment field and work better if there was none. In general the comments are useful to the human reader and specific to the last program to output the data. So box modelers may have the conditions used to create the curve, like Vb, Driver name and T/S parameters, etc.@*

It is usually better that the data blocks have boundaries on the numbers used. Although Scientific Notation is permitted, it is usually better, more accurate and much more readable if the numbers used have exactly four decimal places below the dot (greater accuracy is really not helpful and less has been show to induce jitter from Group Delay derived or other secondary processing). In addition, it greatly simplified the operation of any subsequent program if the Frequency spacing is even and progresses in a log spacing format. This tends to spread the samples evenly over the frequency segment.@*

The Magnitude number is log gain and in db values. The scale can be SPL @ wattage @ distance format (hovering about 90) or a unity aligned offset (usually just above zero for diffraction or starting at and diving below zero steeply for box models and crossover functions). The Phase data is best if in degrees, from –180 to +180 wrapping.@*

In general, there are good reasons to keep the frequency sampling density high enough to accurately represent a complex waveform sequence (without losing detail) but not so dense as to generate large amounts of extra sample data. Usually between 200 to 250 samples per decade, which is about 60 to 75 samples per octave, works very well.@*

When processing files and using the resultants, there are also good reasons to have the response extend at least one octave and preferably 2 or more octaves beyond the region of interest (above and below) so as to keep phase tracking error very low. This is especially important when deriving Minimum Phase or Optimizing crossovers downstream. A good standard to target is the internal default one of the Frequency Response Combiner program, which was selected for those reasons above (sample density and frequency extension) and for a close adherence to digital sound cards sampling rates, and also that the sample set was easily sub-divided into many equal sized integer count pieces (2, 3, 4, 6, 7, 8, 14, 16, 21, 24). The FRC program default standard for internal FRD data calculation is 2 Hz to 96,000 Hz with 1176 equal log spaced samples or about 251 samples per decade.@*
--------------------------------@*


@findex mataa_export_TMD
@node mataa_export_TMD
@section mataa_export_TMD

file: ...mataa_tools/mataa_export_TMD.m@*

function mataa_export_TMD (t,s,comment,file);@*

DESCRIPTION:@*
Export time-domain data to a TMD file (or, in other words: export the samples a signal s(t) to an ASCII file). A TMD file is essentially an ASCII file containing two columns of data: time and signal samples. The 'TMD format' is modelled after the FRD format for frequency-domain data (see mataa_export_FRD for more information).@*

INPUT:@*
t: time values (seconds)@*
s: signal samples@*
comment: string containing a comment to be saved with the data, e.g. a description of the data. Use comment = '' if you do not want a comment in the data file.@*

OUTPUT:@*
(none)@*


@findex mataa_file_default_name
@node mataa_file_default_name
@section mataa_file_default_name

file: ...mataa_tools/mataa_file_default_name.m@*

function name = mataa_file_default_name;@*

DESCRIPTION:@*
This function returns a file name that can be used to save MATAA data. If 'ask' is nonzero, the user is asked to enter a file name. If no answer is given or if 'ask' is zero, a default file name made up of the current date and time of day is returned.@*

INPUT:@*
ask: flag to specify if the user should be asked for a file name. If 'ask' is not specified, ask=0 is assumed.@*

OUTPUT:@*
name: file name@*


@findex mataa_FR_extend_LF
@node mataa_FR_extend_LF
@section mataa_FR_extend_LF

file: ...mataa_tools/mataa_FR_extend_LF.m@*

function [mag,phase,f] = mataa_FR_extend_LF (fh,mh,ph,fl,ml,pl,f1,f2);@*

DESCRIPTION:@*
Extend frequency response (e.g. from an anechoic analysis of a loudspeaker impulse response measured in the far field) with low-frequency data (e.g. from a near-field measurement). The frequency ranges of the two frequency responses need to overlap, and the common data in the frequency range [f1,f2] is used to determine the offsets in the magnitude and phase of the two frequency-response data sets. The low-frequency magnitude and phase (ml, pl) is adjusted to fit the high-frequency data (mh, ph). The phase data (ph, pl) may either be wrapped (e.g. to a range of -180..+180 deg) or unwrapped. After adjusting the relative offsets, the resulting response in the overlap band is computed as the weighted mean of the low and high frequency data, where the weight of the high-frequency data increases linearly from 0 at f1 to 1 at f2 (and vice versa for the low-frequency data).@*

INPUT:@*
mh, ph, fh: magnitude (dB), phase (deg.) and frequency (Hz) data of the frequency response covering the high-frequency range@*
ml, pl, fl: magnitude (dB), phase (deg.) and frequency (Hz) data of the frequency response covering the low-frequency range@*
f1, f2: [f1,f2] is the frequency range used to determine the offsets of the low-frequency magnitude and phase (ml, pl) relative to the high-frequency data (mh, ph).@*

OUTPUT:@*
mag, phase, f: magnitude (dB), phase (deg, unwrapped) and frequency (Hz) of the combined frequency response. The data with f > f2 are identical to (mh,ph,fh), those with f < f1 correspond to (ml,pl,fl) with the magnitude and phase offsets removed. The data in the range [f1,f2] corresponds to the combination of the data of both data sets.@*
 @*

@findex mataa_FR_inbox_convert
@node mataa_FR_inbox_convert
@section mataa_FR_inbox_convert

file: ...mataa_tools/mataa_FR_inbox_convert.m@*

function mag = mataa_FR_inbox_convert (mag,f,Vb,r);@*

DESCRIPTION:@*
Convert SPL frequency response measured inside a loudspeaker box to free-field SPL frequency response (2pi). The method follows the description by R.H. Small (see reference below), but does not implement the compensation of acoustic losses (expressed as QL in the Small paper). The microphone-in-box (MIB) technique is useful to determine the acoustic performance of a loudspaker at low frequencies in the 2pi free field. The MIB technique works well for closed and vented boxes, no matter how many radiators there are. It is not suitable for transmission lines. If Vb and r are specified (optional), the code calculates the absolute free-field SPL response. Otherwise the SPL curve is normalized to 0 dB-SPL at 100 Hz. Note that the method yields the 2pi free field SPL response, so it does not account for baffle edge diffraction of similar effects. Also note that the results are strictly only accurate for frequencies with wavelength that are considerably larger than the longest dimension of the loudspeaker box. However, it is often possible to stretch this limit a bit by experimenting with the microphone position within the box (positioning the microphone close to the geometric center of the box often allows a somewhat higher upper frequency limit).@*

See also:@*
- R.H. Small, “Simplified Loudspeaker Measurements at low Frequencies”, J. Audio Engineering Society, Vol. 20, pp. 28-33, 1972@*
- https://www.audioxpress.com/article/measuring-loudspeaker-low-frequency-response@*

INPUT:@*
mag: SPL magnitude inside the box (in dB-SPL)@*
f: frequency values corresponding to the mag data@*
Vb (optional): box volume (in L)@*
r (optional): distance used to calculate/normalize the free-field SPL level (in m)@*

OUTPUT:@*
mag: free-field frequency response (magnitude in dB-SPL)@*

check input arguments:@*

@findex mataa_FR_smooth
@node mataa_FR_smooth
@section mataa_FR_smooth

file: ...mataa_tools/mataa_FR_smooth.m@*

function [mag,phase,f] = mataa_FR_smooth (mag,phase,f,smooth_interval);@*

DESCRIPTION:@*
Smooth frequency response in octave bands.@*

INPUT:@*
mag: magnitude data@*
phase: phase data@*
f: frequency@*
smooth_interval: width of octave band used for smoothing@*

OUTPUT:@*
mag: smoothed frequency response (magnitude)@*
phase: smoothed frequency response (phase)@*
f: frequency values of smoothed frequency response data@*

EXAMPLE:@*
> [h,t] = mataa_IR_demo; @*
> [mag,phase,f] = mataa_IR_to_FR(h,t); % calculates magnitude(f) and phase(f)@*
> [magS,phaseS,fS] = mataa_FR_smooth(mag,phase,f,1/4); % smooth to 1/4 octave resolution@*
> semilogx ( f,mag , fS,magS ); % plot raw and smoothed data@*

fractional octave between last and second-last data point:@*

@findex mataa_f_to_t
@node mataa_f_to_t
@section mataa_f_to_t

file: ...mataa_tools/mataa_f_to_t.m@*

function t = mataa_f_to_t (f);@*

DESCRIPTION:@*
returns the time bins of the inverse fourier spectrum sampled at frequencies f (f is assumed to be evenly spaced!)@*

INPUT:@*
f: frequency-value vector (in Hz). Values must be sorted and evenly spaced.@*

OUTPUT:@*
t: time values (vector, in seconds)@*


@findex mataa_gnuplot
@node mataa_gnuplot
@section mataa_gnuplot

file: ...mataa_tools/mataa_gnuplot.m@*

function mataa_gnuplot (cmd);@*

DESCRIPTION:@*
This function executes the gnuplot command 'cmd' by calling __gnuplot_raw__(cmd). This only makes sense with Octave if gnuplot is used as the plotting engine. IMPORTANT: THIS FUNCTION SHOULD NOT BE USED ANYMORE, BECAUSE THE GNUPLOT INTERFACE TO OCTAVE HAS CHANGED CONSIDERABLY IN OCTAVE 2.9.X. IT WILL PROPABLY BE CHANGED FURTHER, BREAKING THIS FUNCTION.@*

INPUT:@*
cmd: string containing the gnuplot command.@*


@findex mataa_guess_IR_start
@node mataa_guess_IR_start
@section mataa_guess_IR_start

file: ...mataa_tools/mataa_guess_IR_start.m@*

function [t_start,t_rise] = mataa_guess_IR_start (h,t,fc,verbose);@*

DESCRIPTION:@*
Try to determine the start and and rise time of an impulse response signal.@*

Note: this function calculates the analytic signal to determine the envelope function of h(t), and then analyses the envolope curve to find t_start and t_rise. See, for instance: http://en.wikipedia.org/wiki/Analytic_signal .@*

INPUT:@*
h: impulse response@*
t: time-values vector of impulse response samples (vector, in seconds), or, alternatively, the sampling frequency of h(t) (scalar, in Hz, the first sample in h is assumed to correspond to time t(1)=0).@*
fc (optional): cut-off frequency of high pass filter applied to h(t) before finding the impulse. This is useful if h(t) is masked by low-frequency noise. If fc is not empty, a 4th order Butterworth high-pass filter will be applied to h(t) to remove low-frequency noise.@*
verbose (optional): if verbose=0, no user feedback is given. If not specified, verbose ~= 0 is assumed.@*

OUTPUT:@*
t_start: 'beginning' of h(t) (seconds)@*
t_rise: rise time of h(t) (seconds)@*

EXAMPLE:@*
> [h,t] = mataa_IR_demo; % load demo data of an loudspeaker impulse response.@*
> mataa_plot_IR(h,t); % plot the fake signal@*
> [t_start,t_rise] = mataa_guess_IR_start(h,t,20)@*

This gives t_start = 0.288 ms and t_rise = 0.0694 ms. In this example might therefore safely discard all data with t < t_start. In real-world use (with noise and Murphy's law against us), however, it might be worthwile to add some safety margin, e.g. using t_rise: discard all data with t < t_start - t_rise.@*


@findex mataa_hilbert
@node mataa_hilbert
@section mataa_hilbert

file: ...mataa_tools/mataa_hilbert.m@*

function y = mataa_hilbert (x)@*

DESCRIPTION:@*
Calculates the Hilbert transform of x.@*

This code was modelled after the Hilbert transform function 'hilbert.m' available from Octave-Forge@*

INPUT:@*
x: input signal (column vector). If x contains complex values, only the real part of these values will be used.@*

OUTPUT:@*
y: hilbert transform of x@*


@findex mataa_impedance_fit_speaker_LR2
@node mataa_impedance_fit_speaker_LR2
@section mataa_impedance_fit_speaker_LR2

file: ...mataa_tools/mataa_impedance_fit_speaker_LR2.m@*

function [Rdc,f0,Qe,Qm,L1,L2,R2] = mataa_impedance_fit_speaker_LR2 (f,mag,phase);@*

DESCRIPTION:@*
Fits the impedance model of mataa_impedance_speaker_model_LR2 to the impedance data mag(f) and phase(f). This can be useful in determining Thielle/Small parameters from impedance measurements.@*

INPUT:@*
f: frequency values of the impedance data@*
mag: magnitude of impedance data (Ohm)@*
phase: phase of impedance data (degrees)@*

OUTPUT:@*
Rdc, f0, Qe, Qm, L1, L2, R2: see mataa_impedance_speaker_model_LR2 (input parameters)@*


@findex mataa_impedance_speaker_model_LR2
@node mataa_impedance_speaker_model_LR2
@section mataa_impedance_speaker_model_LR2

file: ...mataa_tools/mataa_impedance_speaker_model_LR2.m@*

function [mag,phase] = mataa_impedance_speaker_model_LR2 (f,Rdc,f0,Qe,Qm,L1,L2,R2)@*

DESCRIPTION:@*
Calculate speaker impedance (magnitude and phase) as a function of frequency f according to the "LR-2 model" (see also Figure 7.16 in J. d'Appolito, "Testing Loudspeakers", Audio Amateur Press). This model essentially consists of a combination of three impedance elements connected in series (where w = 2*pi*f, w0 = 2*pi*f0):@*
(a) The DC resistance of the voice coil (Rdc)@*
(b) A parallel LCR circuit, reflecting the the low-frequency part of the impedance curve (resonance peak).@*
(c) L1 in series with a parallel combination of R2 and L2. L1, L2, and R2 reflect the high-frequency part of the impedance curve. For L2 = 0 and R2 = Inf, this model reduces to the simpler concept where the voice-coil inductance Le is constant with frequency (and L1 = Le).@*

INPUT:@*
f: frequency values for which impedance will be calculatedq@*
Rdc: DC resistance of the voice coil (Ohm)@*
f0: resonance frequency of the speaker (Hz)@*
Qe: electrical quality factor of the speaker (at resonance)@*
Qm: mechanical quality factor of the speaker (at resonance)@*
L1, L2, R2 (optional): see above (in H or Ohm, respectively)@*

OUTPUT:@*
mag: magnitude of impedance (Ohm)@*
phase: phase of impedance (degrees)@*

NOTES:@*
   - The ratio Qm/Qe reflects the height of the impedance peak. If Zmax is the impedance maximum (at resonance) then Zmax/Rdc = Qm/Qe+1.@*
   - Qe reflects the width of the impedance peak (large Qe corresponds to a narrow peak)@*

EXAMPLE:@*
The following gives a good approximation of the data shown in Fig. 7.18 in J. d'Appolito, "Testing oudspeaker" on page 122:@*
f = logspace(1,4,100);@*
[mag,phase] = mataa_impedance_speaker_model (f,7.66,33.22,0.45,3.4,0.4e-3,1.1e-3,13);@*
semilogx (f,mag,f,phase)@*

@findex mataa_impedance_speaker_model_WRIGHT
@node mataa_impedance_speaker_model_WRIGHT
@section mataa_impedance_speaker_model_WRIGHT

file: ...mataa_tools/mataa_impedance_speaker_model_WRIGHT.m@*

function [mag,phase] = mataa_impedance_speaker_model_WRIGHT (f,Rdc,f0,Qe,Qm,Kr,Xr,Ki,Xi)@*

DESCRIPTION:@*
Calculate speaker impedance (magnitude and phase) as a function of frequency f according to the "Wright model" (see "An Empirical Model for Loudspeaker Motor Impedance", J R Wright, AES Preprint, 2776 (S-2), 1989). This model essentially consists of a combination of three impedance elements connected in series (where w = 2*pi*f, w0 = 2*pi*f0):@*
(a) The DC resistance of the voice coil (Rdc)@*
(b) A parallel LCR circuit, reflecting the the low-frequency part of the impedance curve (resonance peak).@*
(c) an empirical term that describes the impedance rise above the resonance peak: Z = Kr w^Xr + i Ki w^Xi@*

INPUT:@*
f: frequency values for which impedance will be calculatedq@*
Rdc: DC resistance of the voice coil (Ohm)@*
f0: resonance frequency of the speaker (Hz)@*
Qe: electrical quality factor of the speaker (at resonance)@*
Qm: mechanical quality factor of the speaker (at resonance)@*
Kr,Xr,Ki,Xi (optional): see above@*

OUTPUT:@*
mag: magnitude of impedance (Ohm)@*
phase: phase of impedance (degrees)@*

NOTES:@*
   - The ratio Qm/Qe reflects the height of the impedance peak. If Zmax is the impedance maximum (at resonance) then Zmax/Rdc = Qm/Qe+1.@*
   - Qe reflects the width of the impedance peak (large Qe corresponds to a narrow peak)@*

EXAMPLE:@*
> f = logspace(1,4,1000);@*
> Rdc = 6.1; f0 = 45; Qe = 0.35; Qm = 5.0;@*
> Kr = 4.5E-3; Ki = 27E-3; Xr = 0.65; Xi = 0.68;@*
> [mag,phase] = mataa_impedance_speaker_model_WRIGHT (f,Rdc,f0,Qe,Qm,Kr,Xr,Ki,Xi);@*


@findex mataa_import_AIFF
@node mataa_import_AIFF
@section mataa_import_AIFF

file: ...mataa_tools/mataa_import_AIFF.m@*

function [t,s] = mataa_import_AIFF (file)@*

DESCRIPTION:@*
Import time-domain data from an AIFF file. This function requires the sndfile-convert utiliy, which is part of libsndfile ( http://www.mega-nerd.com/libsndfile ).@*

INPUT:@*
file: string containing the name of the file containing the data to be imported. The string may contain a complete path. If no path is given, the file is assumed to be located in the current working directory.@*

OUTPUT:@*
t: time values (s)@*
s: signal samples@*


@findex mataa_import_FRD
@node mataa_import_FRD
@section mataa_import_FRD

file: ...mataa_tools/mataa_import_FRD.m@*

function [f,mag,phase,comments] = mataa_import_FRD (file);@*

DESCRIPTION:@*
Import frequency-domain data from a FRD file.@*
(see also mataa_export_FRD).@*

INPUT:@*
file: string containing the name of the file containing the data to be imported. The string may contain a complete path. If no path is given, the file is assumed to be located in the current working directory.@*

OUTPUT:@*
f: frequency values (Hz)@*
mag: magnitude values@*
phase: phase@*
comments: cell string containing the comments in the data file (if any)@*

HISTORY:@*
9. January 2008  (Matthias Brennwald): first version@*

@findex mataa_import_mlssa
@node mataa_import_mlssa
@section mataa_import_mlssa

file: ...mataa_tools/mataa_import_mlssa.m@*

function [mlsvec,mlsfs,stimulus_amp,mlsdf] = mataa_import_mlssa (File,Outfile,Withir);@*

Reads a MLSSA .TIM or .FRQ file and extracts all data from it. Note that this function has been designed using Matlab only (i.e. it might not work as well with Octave).@*

INPUT:@*
File (optional): should contain the filename, including path and extension (.TIM or .FRQ). If File is empty, a file dialog is presented.@*
Outfile: should contain a filename, including path but no extension (will be given.mat). The output data will be saved in this file.@*
Withir (optional): parameter, should be included and with the text 'Withir' if the impulse response (or transfer function) mlsvec should be included in the Output file.@*

OUTPUT:@*
mlsvec	       the impulse response (for .TIM files) or the transfer function (for .FRQ@*
	       files; containing nfft/2 + 1 complex values).@*
mlsfs	       the sampling frequency@*
stimulus_amp   the stimulus amplitude used during the measurement@*
mlsdf	       the frequency increment (only for .FRQ files)@*

Comment 1:    Note that an MLS file (.TIM or .FRQ) is half the size of the@*
	corresponding Matlab file (MLSSA uses single precision whereas Matlab@*
	uses double precision). Thus the MLS files can be used and opened every time@*
	data is needed, instead of creating a Matlab copy of the file.@*

Comment 2:	The output parameter stimulus_amp might be needed to scale the impulse@*
	response correctly. MLSSA does not scale the impulse versus the stimulus_amp@*
	so that if different stimulus_amp have been used, the corresponding impulse@*
	responses will display different amplitudes. The transfer functions (.FRQ)@*
	are however scaled correctly.@*

Comment 3:	The impulse response can be retrieved from the transfer function by inserting@*
	the values for negative frequencies:@*
	   [mlsvec,mlsfs,stimulus_amp,mlsdf] = readmls('TEST.FRQ',Outfile);@*
	   npoints = length(mlsvec);@*
	   mlsvec = [mlsvec; conj(mlsvec( npoints-1:-1:2 ))];@*
	   ir = real(ifft(mlsvec));	% ir should be a real quantity. Any remaining@*
					% imaginary values will reflect numerical errors@*
					% or an incorrect transfer function.@*
	Note however that if a window was used before calculating the transfer function@*
	the windowed impulse response will be extracted.@*

Comment 4:	The MLSSA files contain a large number of auxilliary parameters that are saved in@*
	the Outfile. Refer to the appendix of the MLSSA manual for information about these@*
	parameters, which are those in the setup of the MLSSA measurements. According to@*
	the manual, this setup structure can be changed in future versions. This one is@*
	valid for version 9.0.@*

The program is based on code written by Peter Svensson (svensson[at]iet.ntnu.no) available at http://www.iet.ntnu.no/~svensson/readmls.m. Peter Svensson explicitly agreed to provide his work for inclusion in MATAA.@*

@findex mataa_import_PIR
@node mataa_import_PIR
@section mataa_import_PIR

file: ...mataa_tools/mataa_import_PIR.m@*

function [t,s,info] = mataa_import_PIR (file);@*

DESCRIPTION:@*
Import time-domain data from a PIR file (binary ARTA data file).@*

INPUT:@*
file: string containing the name of the file containing the data to be imported. The string may contain a complete path. If no path is given, the file is assumed to be located in the current working directory.@*

OUTPUT:@*
t: time values (s)@*
s: signal amplitude values@*
info: data information (as described in ARTA manual, see also m-file code in this file)@*

HISTORY:@*
26. October 2019  (Matthias Brennwald): first version@*

@findex mataa_import_TMD
@node mataa_import_TMD
@section mataa_import_TMD

file: ...mataa_tools/mataa_import_TMD.m@*

function [t,s,comments] = mataa_import_TMD (file,timefix)@*

DESCRIPTION:@*
Import time-domain data from a TMD file (see also mataa_export_TMD).@*

INPUT:@*
file: string containing the name of the file containing the data to be imported. The string may contain a complete path. If no path is given, the file is assumed to be located in the current working directory.@*
timefix (optional): flag indicating if (and how) mataa_import_TMD should try to make time values evenly spaced. If timefix > 1: t = timefix * round (1/mean(diff(t))/timefix)@*

OUTPUT:@*
t: time values (s)@*
s: signal samples@*
comments: cell string containing the comments in the data file (if any)@*

EXAMPLE:@*

> [t,h,comments] = mataa_import_TMD ('scanspeaker_0deg_no_filter_tweeter.tmd',10);@*

@findex mataa_interp
@node mataa_interp
@section mataa_interp

file: ...mataa_tools/mataa_interp.m@*

function y = mataa_interp (xi,yi,x);@*

DESCRIPTION:@*
Linear interpolation of y(x) from yi(xi)@*
if x is outside the range of xi, mataa_interp returns a linear extrapolation of the yi@*

Linear interpolation is of course available in Matlab and Octave-Forge as interp1. However, it's not available in plain-vanilla Octave, which is a shame, I think (this was fixed a while ago, so mataa_interp is obsolete and may be removed in the future). I therefore provided this function for MATAA so that I don't have to worry about interp1 missing in Octave while still being able to easily write code that is compatible with both Matlab and Octave.@*

FIXME: THIS CODE IS AS INEFFICIENT AS IT GETS!@*


@findex mataa_IR_demo
@node mataa_IR_demo
@section mataa_IR_demo

file: ...mataa_tools/mataa_IR_demo.m@*

function [h,t,unit] = mataa_IR_demo (IRtype)@*

DESCRIPTION:@*
This function returns the an impulse response h(t), specified by 'IRtype'.@*

INPUT:@*
type (optional): string describing the type of impulse response (see below). If not specified, type = 'DEFAULT' is used.@*

valid choices for 'IRtype':@*

FE108: impulse response of a Fostex FE108Sigma full-range driver, sampled at a rate of 96 kHz.@*

DIRAC: dirac impulse (first sample is 1, all others are zero), with a length of 1 second, sampled at 44.1 kHz.@*

EXP: exponential decay ( f(t) = exp(-t/tau), with tau=1E-2 seconds), with a length of 1 second, sampled at 44.1 kHz.@*

DEFAULT: same as 'FE108'.@*
 @*
OUTPUT:@*
h: impulse response samples@*
t: time coordinates of samples@*
unit: unit of data in h@*


@findex mataa_IR_remove_echo
@node mataa_IR_remove_echo
@section mataa_IR_remove_echo

file: ...mataa_tools/mataa_IR_remove_echo.m@*

function [h,t] = mataa_IR_remove_echo (h,t,t_echo_start,t_echo_end);@*

DESCRIPTION:@*
This function removes echos from an impulse response. The echos are replaced by data calculated by linear interpolation.@*

INPUT:@*
h: values impulse response (vector)@*
t: time values of samples in h (vector)@*
t_echo_start: start time of echo@*
t_echo_end: end time of echo@*

OUTPUT:@*
h: values impulse response with echo removed@*
t: time values of samples in h@*
 @*

@findex mataa_IR_to_CSD
@node mataa_IR_to_CSD
@section mataa_IR_to_CSD

file: ...mataa_tools/mataa_IR_to_CSD.m@*

function [spl,f,d] = mataa_IR_to_CSD (h,t,T,smooth_interval);@*

DESCRIPTION:@*
This function calculates cumulative spectral decay (CSD) data (SPL-responses spl at frequencies f and delay times d).@*

INPUT:@*
h: values impulse response (vector)@*
t: time values of samples in h (vector, in seconds) or sampling rate of h (scalar, in Hz)@*
T: desired delay times (should be evenly spaced)@*
smooth_interval (optional): if supplied, the SPL curves are smoothed using mataa_IR_to_FR_smooth@*

OUTPUT:@*
spl: CSD data (dB)@*
f: frequency (Hz)@*
d: delay of CSD data (seconds)@*
 @*
EXAMPLE:@*
[h,t] = mataa_IR_demo ('FE108');@*
T = [0:1E-4:4E-3];@*
[spl,f,t] = mataa_IR_to_CSD (h,t,T,1/24);@*
mataa_plot_CSDt (spl,f,t,50);@*


@findex mataa_IR_to_ETC
@node mataa_IR_to_ETC
@section mataa_IR_to_ETC

file: ...mataa_tools/mataa_IR_to_ETC.m@*

function [etc,t] = mataa_IR_to_ETC (h,t);@*

DESCRIPTION:@*
This function calculates the energy-time-curve (ETC) from the impulse response h(t).@*
The ETC is the envelope (magnitude) of the analytic signal of h (see D'Appolito, J.: Testing Loudspeakers, p. 125)@*

INPUT:@*
h: impulse response (in volts)@*
t: time coordinates of samples in h (vector, in seconds) or sampling rate of h (scalar, in Hz)@*

OUTPUT:@*
etc: energy-time curve@*
t: time coordinates of etc (in seconds)@*

EXAMPLE:@*
> [h,t] = mataa_IR_demo;@*
> [etc,t] = mataa_IR_to_ETC(h,t);@*
> mataa_plot_ETC_lin(etc,t)@*

@findex mataa_IR_to_FR_LFextend
@node mataa_IR_to_FR_LFextend
@section mataa_IR_to_FR_LFextend

file: ...mataa_tools/mataa_IR_to_FR_LFextend.m@*

function [mag,phase,f,unit] = mataa_IR_to_FR_LFextend (h,t,t1,t2,t3,N,smooth_interval,unit);@*

DESCRIPTION:@*
Calculate frequency response (magnitude in dB and phase in degrees) of a loudspeaker with impulse response h(t) in two steps: first, the anechoic part (t < T0) is windowed and fourier transformed. Then, low-frequency bins in the range f0...1/T0 are added by using the part of the impulse response after T0 (the low-frequency response is therefore not anechoic).@*

INPUT:@*
h: impulse response (in volts)@*
t: time coordinates of samples in h (vector, in seconds) or sampling rate of h (scalar, in Hz)@*
t1, t2, t3: time ranges of the anechoic and the following echoic parts, relative to the first value in t. [t1,t2] is the time range used to calculate the anechoic frequency response, [t1,t3] the time range used to extend the frequency response towards lower frequencies (echoic part).@*
N: number of frequency-response values to calculate in echoic frequency range@*
smooth_interval (optional): if specified, the frequency response is smoothed over the octave interval smooth_interval.@*
unit: see mataa_IR_to_FR@*

OUTPUT:@*
mag: magnitude of frequency response (in dB)@*
phase: phase of frequency response (in degrees). This is the TOTAL phase including the 'excess phase' due to (possible) time delay of h(h). phase is unwrapped (i.e. it is not limited to +/-180 degrees, and there are no discontinuities at +/- 180 deg.)@*
f: frequency coordinates of mag and phase@*
unit: see mataa_IR_to_FR@*


@findex mataa_IR_to_FR
@node mataa_IR_to_FR
@section mataa_IR_to_FR

file: ...mataa_tools/mataa_IR_to_FR.m@*

function [mag,phase,f,unit] = mataa_IR_to_FR (h,t,smooth_interval,unit);@*

DESCRIPTION:@*
Calculate frequency response (magnitude in dB and phase in degrees) of a system with impulse response h(t)@*

INPUT:@*
h: impulse response (in volts, Pa, FS, etc.)@*
t: time coordinates of samples in h (vector, in seconds) or sampling rate of h (scalar, in Hz)@*
smooth_interval (optional): if specified, the frequency response is smoothed over the octave interval smooth_interval.@*
unit (optional): unit of h. If no unit is given, unit = 'FS' is assumed.@*
Known units:@*
unit = 'V' (Volt)@*
unit = 'Pa' (Pascal)@*
unit = 'FS' (digital Full Scale, values ranging from -1 to +1).@*

OUTPUT:@*
mag: magnitude of frequency response (in dB). Depending on the unit of h, mag is references to different levels:@*
- Unit of h is 'Pa' (Pascal) --> mag is referenced to 20 microPa (standard RMS reference sound pressure level).@*
- Unit of h is 'V' (Volt) --> mag is referenced to 1.0 V(RMS).@*
phase: phase of frequency response (in degrees). This is the TOTAL phase including the 'excess phase' due to (possible) time delay of h(h). phase is unwrapped (i.e. it is not limited to +/-180 degrees, and there are no discontinuities at +/- 180 deg.)@*
f: frequency coordinates of mag and phase@*
unit: unit of mag (depends on unit given at input):@*
input unit = 'V'  ---> output unit = 'dB-V(rms)'   // a sine wave with a RMS level of 1V(rms) corresponds to 0 dB-V(rms)@*
input unit = 'Pa' ---> output unit = 'dB-SPL(rms)' // a sine wave with a RMS SPL of 2E-5Pa(rms) corresponds to 0 dB-SPL(rms)@*
input unit = 'FS' ---> output unit = 'dB-FS(rms)'  // a sine wave with a RMS level of 0.707FS (1.0FS peak amplitude) corresponds to 0 dB-FS(rms)@*

EXAMPLE:@*
> [h,t,unit_h] = mataa_IR_demo ('FE108'); % load demo IR (Fostex FE-108 speaker)@*
> [mag,phase,f,unit_mag] = mataa_IR_to_FR(h,t,1/12,unit_h); % calculate magnitude(f) and phase(f), smoothed to 1/12 octave resolution@*
> subplot (2,1,1); semilogx (f,mag); ylabel (sprintf('SPL (%s)',unit_mag)); % plot magnitude response@*
> subplot (2,1,2); semilogx (f,phase); ylabel ('Phase (deg.)'); xlabel ('Frequency (Hz)'); % plot phase response@*


@findex mataa_IR_to_SR
@node mataa_IR_to_SR
@section mataa_IR_to_SR

file: ...mataa_tools/mataa_IR_to_SR.m@*

function [s,t] = mataa_IR_to_SR (h,t);@*

DESCRIPTION:@*
calculates the step response of a system with impulse response h(t)@*

INPUT:@*
h: impulse response@*
t: time coordinates of samples in h (vector, in seconds) or sampling rate of h (scalar, in Hz)@*

OUTPUT:@*
s: step response@*
t: time (seconds)@*


@findex mataa_IR_to_TBES
@node mataa_IR_to_TBES
@section mataa_IR_to_TBES

file: ...mataa_tools/mataa_IR_to_TBES.m@*

function [A,tau,f] = mataa_IR_to_TBES (h,t,f);@*

DESCRIPTION:@*
Calculate tone burst energy storage (TBES) data. The impulse response is convolved with shaped tone burst(s) to analyze the transient response and energy storage of the DUT at different frequencies. Tone burst signals used are 4 cycles of pure sine with a Blackman envelope.@*
The method is based on the ideas of Siegfried Linkwitz (see http://www.linkwitzlab.com/frontiers_2.htm#M ) and Jochen Fabricius.@*

INPUT:@*
h: values impulse response (vector)@*
t: time values of samples in h (vector, in seconds) or sampling rate of h (scalar, in Hz)@*
f: frequency value(s) of tone burst (Hz)@*

OUTPUT:@*
A: amplitude envelope (dB, relative to max value)@*
tau: dimensionless time value (time normalized by period of burst frequency)@*
f: frequency values (same values as in input, useful for plotting TBES results)@*
 @*
EXAMPLE:@*
> [h,t] = mataa_IR_demo ('FE108');@*
> f = logspace (2,4,50);@*
> [A,tau,f] = mataa_IR_to_TBES (h,t,f);@*


@findex mataa_load_calibration
@node mataa_load_calibration
@section mataa_load_calibration

file: ...mataa_tools/mataa_load_calibration.m@*

function cal = mataa_load_calibration (calfile)@*

DESCRIPTION:@*
Load calibration data for test devices from calibration file.@*

INPUT:@*
calfile: name of calibration file (e.g., "Behringer_ECM8000.txt")@*

OUTPUT:@*
cal: struct with calibration data.@*

EXAMPLE:@*
To load the (generic) calibration data for a Behringer ECM8000 microphone:@*
c = mataa_load_calibration ('BEHRINGER_ECM8000_D1303397118_MICROPHONE.txt');@*


@findex mataa_measure_GedLee
@node mataa_measure_GedLee
@section mataa_measure_GedLee

file: ...mataa_tools/mataa_measure_GedLee.m@*

function [Gm,tf] = mataa_measure_GedLee ( f0,T,fs,N_h,latency,cal,amplitude,unit,N_avg,do_plot);@*

DESCRIPTION:@*
Measure the GedLee distortion metric. This is achieved by measuring the distortion harmonics from a sine signal to construct the transfer function of the system, which is analysed according to the GedLee metric to obtain "Gm".@*

INPUT:@*
(see mataa_measure_HD_noise)@*
'amplitude' may be specified as a vector of different amplitude values.@*
do_plot (optional): flag (boolean) or figure number (positive integer). Use this to set plotting of the DUT output spectrum used to determine the transfer function for GedLee analysiss. This is useful to check if the right number of harmonics (N_h) is used, or if the hardmonics are lost in the noise floor (default: do_plot = 15).@*

OUTPUT:@*
Gm: GedLee metric@*
tf: normalised transfer function (as used to determine Gm)@*

REFERENCES:@*
[1] "Weighting Up", Keith Howard@*

EXAMPLE-1:@*
[Gm,tf] = mataa_measure_GedLee (1000,0.3,44100,10,0.2);@*
plot (linspace(-1,1,length(tf)),tf);@*
xlabel ('Input (normalised)'); ylabel ('Output (normalised)'); title ('Transfer function')@*

EXAMPLE-2:@*
ampl = logspace(-3,0,10)*5;@*
[Gm,tf] = mataa_measure_GedLee (1000,0.3,88200,10,0.2,'MB_ACOUSTIC_CHAIN_DUT.txt',ampl,'V',3);@*
semilogx (ampl/sqrt(2),Gm)@*
xlabel ('Signal (V-RMS)'); ylabel ('Gm value')@*


@findex mataa_measure_HD_noise
@node mataa_measure_HD_noise
@section mataa_measure_HD_noise

file: ...mataa_tools/mataa_measure_HD_noise.m@*

function [HD,fHD,THD,THDN,L,f,unit] = mataa_measure_HD_noise ( f0,T,fs,N_h,latency,cal,amplitude,unit,window,fLow,fHigh,N_avg );@*

DESCRIPTION:@*
Measure harmonic distortion and total harmonic distortion plus noise (THD+N). If necessary, the fundamental frequency (f0) is adjusted to match the center of the closest FFT bin to avoid smearing of the spectrum.@*

INPUT:@*
f0: fundamental frequency (Hz).@*
T: length of sine signal in seconds.@*
fs: sampling frequency in Hz@*
N_h: number of harmonics to consider (including the fundamental)@*
latency (optional): see mataa_measure_signal_response (default: latency = [])@*
cal (optional): calibration data for data calibration (see mataa_signal_calibrate for details).@*
amplitude and unit (optional): amplitude and unit of test signal at DUT input (see mataa_measure_signal_response). Note that the 'unit' controls the amplitude of the analog signal at the DUT input. Default: amplitude = 1, unit = 'digital'.@*
window (optional): window function to be applied to the DUT response before calculating the spectrum (default: window = 'none'). See also mataa_signal_window(...). If the window function requires additional parameter, then window can be given as a struct with three fields corresponding to the mataa_signal_window(...) arguments as follows:@*
window.name = 'window' input argument of mataa_signal_window(...)@*
window.par  = 'par' input argument of mataa_signal_window(...)@*
	window.len  = 'len' input argument of mataa_signal_window(...) @*
fLow,fHigh (optional): frequency bandwith of analysis (default: fLow = [], fHigh = []):@*
- If fLow is not empty, only spectral data at frequencies larger or equal to fLow are used for the analysis.@*
- If fHIgh is not empty, only spectral data at frequencies lower or equal to fHigh are used for the analysis.@*
N_avg (optional): number of averages (integer, default: N_avg = 1). If N_avg > 1, the measurement is repeated N_avg times, and the mean result is returned. This is useful to reduce the noise floor.@*

OUTPUT:@*
HD: amplitudes (zero-to-peak) and phase angles (radians) of the fundamental and harmonics (size(HD) = [2,N_h]).@*
fHD: frequency values of the fundamental and harmonics (Hz)@*
THD: total harmonic distortion ratio (THD = sqrt(sum(HD(2:end).^2))/HD(1), following the AD convention for normalisation@*
THDN: THD + noise (THD+N) ratio. THD+N ratio = RMS level of the measured distortion plus noise (with the fundamental removed) divided by the level of the fundamental (following the AD convention).@*
L and fL: full spectrum (see mataa_measure_sine_distortion)@*
unit: unit of data in HD and L.@*

NOTE:@*
The THD ratio and the THD+N ratio are normalised to the level of the fundamental (as described in [1,2]). The alternative convention of normalising to the full signal including harmonics or noise (as used by Audio Precision, for example) is discouraged, because it may cause errors and misinterpretation [1,2].@*

REFERENCES:@*
[1] "On the Definition of Total Harmonic Distortion and Its Effect on Measurement Interpretation", Doron Shmilovitz, IEEE TRANSACTIONS ON POWER DELIVERY, VOL. 20, NO. 1, JANUARY 2005, http://www.eng.tau.ac.il/~shmilo/10.pdf@*
[2] "Understand SINAD, ENOB, SNR, THD, THD + N, and SFDR so You Don't Get Lost in the Noise Floor", Walt Kester, Analog Devices MT-003, http://www.analog.com/media/en/training-seminars/tutorials/MT-003.pdf@*

EXAMPLE-1 (harmonic distorion + noise analysis with 1 kHz fundamental, 1 second test signal, 44.1 kHz sampling rate, includ 10 peaks in analysis (fundamental + 9 harmonics):@*
[HD,fHD,THD,THDN,L,fL,unit] = mataa_measure_HD_noise ( 1000,1,44100,10,0.2 );@*
subplot (2,1,1)@*
semilogy (fL,L(:,1)/sqrt(2),'k-' , fHD,HD(1,:)/sqrt(2),'ro' );@*
xlim([0,fHD(end)])@*
ylabel ('Amplitude (RMS uncal.)')@*
subplot (2,1,2)@*
plot ( fHD,HD(2,:)/pi*180,'ro' );@*
xlim([0,fHD(end)])@*
ylabel ('Phase (deg.)')@*
xlabel ('Frequency (Hz)');@*

EXAMPLE-2 (like EXAMPLE-1, but with calibrated 0.3 V test signal amplitude, Hann window, bandwith-limit 100 to 10500 Hz, 5 averages)@*
[HD,fHD,THD,THDN,L,fL,unit] = mataa_measure_HD_noise ( 1000,1,44100,10,0.2,'MB_ELECTRONIC_CHAIN.txt',0.3,'V','hann',100,10500,5 );@*
semilogy ( fL,L(:,1)/sqrt(2),'k-' , fHD,HD(1,:)/sqrt(2),'ro' )@*
ylabel (sprintf('Amplitude (%s-RMS)',unit))@*
xlabel ('Frequency (Hz)');@*

check arguments:@*

@findex mataa_measure_impedance
@node mataa_measure_impedance
@section mataa_measure_impedance

file: ...mataa_tools/mataa_measure_impedance.m@*

function [Zmag,Zphase,f] = mataa_measure_impedance (fLow,fHigh,R,fs,resolution,cal,amplitude,unit,latency);@*

DESCRIPTION:@*
This function measures the complex, frequency-dependent impedance Z(f) of a DUT using a swept sine signal ranging from fLow to fHigh. Note the fade-in and fade-out of the test signal results in a loss of precision at the frequency extremes, which may be compensated by using a slightly larger frequency range.@*

The measurement relies on the following set up:@*

DAC-out -------+---------> ADC-in (REF)@*
	       |@*
	       R@*
	       |@*
	       +---------> ADC-in (DUT)@*
	       |@*
	      DUT@*
	       |@*
DAC-GND -------+---------> ADC-GND@*

Note that the current flowing through the reference resistor R is identical to the current flowing through the DUT at all times. This allows calculating the impedance of the DUT using Ohm's Law with the voltages observed at the ADC inputs of the REF and DUT channels. @*

INPUT:@*
fLow: lower limit of the frequency range (Hz)@*
fHigh: upper limit of the frequency range (Hz)@*
R: resistance of the reference resistor (Ohm)@*
fs (optional): sampling frequency to be used for sound I/O. If not value is given, the lowest possible sampling frequency will be used.@*
resolution (optional): frequency resolution in octaves (example: resolution = 1/24 will give 1/24 octave smoothing). Default is resolution = 1/48. If you want no smoothing at all, use resolution = 0.@*
cal (optional): calibration data (see mataa_signal_calibrate for details). This is required only if the signal amplitude used for the measurement needs to be set to a specific level.@*
amplitude and unit (optional): amplitude and unit of test signal at DUT input (see mataa_measure_signal_response). These parameters are used only if 'cal' is specified. Note that the 'unit' controls the amplitude of the analog signal at the DUT input. Default: amplitude = 1, unit = 'digital'.@*
latency (optional): see mataa_measure_signal_response (default: latency = [])@*

OUTPUT:@*
Zabs: impedance magnitude (Ohm)@*
Zphase: impedance phase (degrees)@*
f: vector of frequency values@*

EXAMPLE 1 (simple measurement from 10 Hz to 20 kHz, using a reference resistor R=8.0 Ohm, with unspecified signal level):@*
[Zmag,Zphase,f] = mataa_measure_impedance (10,20000,8.0,44100);@*
semilogx (f,Zmag); xlabel ('Frequency (Hz)'); ylabel ('Impedance (Ohm)')@*

EXAMPLE 2 (similar to above, but without smoothing and using a sweep amplitude of +/- 3.0 V-pk):@*
[Zmag,Zphase,f] = mataa_measure_impedance (10,20000,8.0,44100,0,'MB_ELECTRONIC_CHAIN.txt',3.0,'V');@*
subplot (2,1,1); semilogx (f,Zphase); ylabel ('Phase (deg.)')@*
subplot (2,1,2); semilogx (f,Zmag); xlabel ('Frequency (Hz)'); ylabel ('Impedance (Ohm)')@*

check arguments:@*

@findex mataa_measure_IR_HD
@node mataa_measure_IR_HD
@section mataa_measure_IR_HD

file: ...mataa_tools/mataa_measure_IR_HD.m@*

function hi = mataa_measure_IR_HD (P, T, fs, N, tL, latency, cal, A, unit)@*

DESCRIPTION:@*
Measures the impulse response and the harmonic distortion products using the "Farina method". This uses an exponential sine sweep (chirp) as a test signal. The sweep of length T contains an integer number of octaves down from the Nyquist frequency. The impulse responses of the fundamental and harmonic distorion products are determined by convolving the DUT response with the inverse filter corresponding to the chirp signal. The magnitude spectrum ripple in the high-frequency extreme is minimized due to the sweep beginning and ending in phase zero. A Hanning fade-in is applied for the first octave, so the flat spectrum is (P - 1) octaves long. Similarly, a Hanning fade-out is applied to the last 1/24 octave to reduce the ripple even more.@*
The REF input channel is not used.@*

REFERENCES:@*
A. Farina, “Simultaneous Measurement of Impulse Response and Distortion with a Swept-Sine Technique”, presented at 108th AES Convention, Paris, France, Feb. 19-22, 2000. Paper 5093. @*
Ian H. Chan: "Swept Sine Chirps for Measuring Impulse Response", Technical Note, Stanford Research Systems, Inc, 2010. Available at http://www.thinksrs.com/downloads/PDFs/ApplicationNotes/SR1_SweptSine.pdf@*
K. Vetter, S. di Rosario: "ExpoChirpToolbox: a Pure Data implementation of ESS impulse response measurement", Rotterdam/London, July 2011. Available at http://www.uni-weimar.de/medien/wiki/PDCON:Conference/Pure_Data_implementation_of_an_ESS-based_impulse_response_acoustic_measurement_tool. ExpoChirpToolbox page: http://www.katjaas.nl/expochirp/expochirp.html.@*

NOTEs:@*
(1) The original code was contributed by estearg (github) on 24.12.2017+30.12.2017 and modified to better suit the MATAA way of code.@*
(2) This code went through substantial changes and fixes (Aug 2019), because it was hard to use and gave wrong results. After substantial testing and comparison with discrete distortion testing, the distortion results now seem to be consistent with those obtained from conventional (discrete frequency) methods.@*

INPUT:@*
P: integer number of octaves, of which the first will be spent on a fade-in window@*
T: desired sweep duration@*
fs: sampling frequency@*
N: number of harmonics included in the analysis@*
tL: length of anechoic part of impulse response (seconds)@*
latency (optional): see mataa_measure_signal_response@*
cal (optional): see mataa_measure_signal_response@*
A and unit (optional): amplitude and unit of test signal at DUT input (see mataa_measure_signal_response). Note that the 'unit' controls the amplitude of the analog signal at the DUT input. Default: amplitude = 1, unit = 'digital'@*

OUTPUT:@*
hi: vector of structs with measured data. hi(1) corresponds to the fundamental, h(k) to the k-th harmonic, with k = 2...N.@*
hi(k).mag: magitude data@*
hi(k).phase: phase data@*
hi(k).mag_unit: unit of mag@*
hi(k).percent: percentage of harmonic amplitude relative to fundamental@*
hi(k).f: frequency values for mag, phase and percent@*
hi(k).h: impulse response data@*
hi(k).h_unit: unit of h@*
hi(k).t: time values for impulse response data@*

EXAMPLE:@*
> % Measure anechoic loudspeaker response (above 300 Hz) and harmonic distortions (2nd and 3rd) using P=8 octaves, T=3 s, fs=96 kHz, default latency, and 1 V (peak-to-zero) drive voltage:@*
> h = mataa_measure_IR_HD (8,3,96000,3,1/300,[],'MB_ACOUSTIC_CHAIN_DUT.txt',1,'V');@*
> figure(1);@*
> semilogx (h(1).f,h(1).mag,'k-;Fundamental;' , h(2).f,h(2).mag,'b-;2nd;' , h(3).f,h(3).mag,'r-;3rd;'); % plot absolute levels@*
> xlim([300 20E3]); ylabel ('dB-SPL'); xlabel ('Frequency (Hz)');@*
> figure(2);@*
> loglog(h(2).f,h(2).percent,'-b;2nd;' , h(3).f,h(3).percent,'r-;3rd;') % plot levels relative to fundamental@*
> xlim([300 20E3]); ylabel ('HD (%)'); xlabel ('Frequency (Hz)');@*


@findex mataa_measure_IR
@node mataa_measure_IR
@section mataa_measure_IR

file: ...mataa_tools/mataa_measure_IR.m@*

function [h,t,unit] = mataa_measure_IR (test_signal,fs,N,latency,loopback,cal,unit);@*

DESCRIPTION:@*
This function measures the impulse response h(t) of a system using sample rate fs. The sampling rate must be supported by the audio device and by the TestTone program. See also mataa_measure_signal_response. h(t) is determined from the deconvolution of the DUT's response and the original input signal (if no loopback is used) or the REF channel (with loopback). The allocation of the DUT (and REF) channel is determined using mataa_settings ('channel_DUT') (and mataa_settings ('channel_REF')).@*
Note that the deconvolution result is normalised to the level of signal at the DUT input / DAC(+BUFFER) output. In order to remove this normalisation of the impulse response (h), the function multiplies the deconvolution result by the RMS signal level of the signal at the DUT input (if the DUT input signal level is available from the calibraton process).@*

INPUT:@*
test_signal: test signal, vector of signal samples (can be a chirp, MLS, pink noise, Dirac, etc.).@*
N (optional): the impulse response is measured N times and the mean response is calculated from these measurements. N = 1 is used by default.@*
latency: see mataa_measure_signal_response@*
loopback (optional): flag to control the behaviour of deconvolution of the DUT and REF channels. If loopback = 0, the DUT signal is not deconvolved from the REF signal (no loopback calibration). Otherwise, the DUT signal is deconvolved from the REF channel. The allocation of the DUT and REF channels is taken from mataa_settings('channel_DUT') and mataa_settings('channel_REF'). Default value (if not specified) is loopback = 0.@*
cal (optional): calibration data (struct or (cell-)string, see mataa_load_calibration and mataa_signal_calibrate)@*
unit (optional): unit of test_signal (see mataa_measure_signal_response). Note that this controls the amplitude of the analog signal at the DUT input.@*

OUTPUT:@*
h: impulse response@*
t: time@*
unit: unit of data in h@*

EXAMPLE:@*

Measure impulse response of a loudspeaker using a sweep test signal (without any data calibration):@*
> % measure impulse response using chirp test signal, allowing for 0.1 s latency of sound in/out@*
> fs = 44100; s = mataa_signal_generator ('sweep',fs,1,[50 20000]); % test signal@*
> [h,t,unit] = mataa_measure_IR (s,fs,1,0.1,0,'GENERIC_CHAIN_ACOUSTIC.txt');@*
> plot (t,h); xlabel ('Time (s)'); ylabel (sprintf('Amplitude (%s)',unit)); % plot result@*


@findex mataa_measure_signal_response
@node mataa_measure_signal_response
@section mataa_measure_signal_response

file: ...mataa_tools/mataa_measure_signal_response.m@*

function [dut_out,dut_in,t,dut_out_unit,dut_in_unit] = mataa_measure_signal_response (X0,fs,latency,verbose,channels,cal,X0_unit);@*

DESCRIPTION:@*
This function feeds one or more test signal(s) to the DUT(s) and records the response signal(s).@*
See also note on channel numbers and allocation of DAC, ADC and cal channel numbers below!@*

INPUT:@*
X0: test signal with values ranging from -1...+1. For a single signal (same signal for all DAC output channels), X0 is a vector. For different signals, X0 is a matrix, with each column corresponding to one channel@*
fs: the sampling rate to be used for the audio input / output (in Hz). Only sample rates supported by the hardware (or its driver software) are supported.@*
latency: the signal data in X0 are padded with zeros at the beginning and end to avoid cutting off the test signals early due to the latency of the sound input/output device(s). 'latency' is the length of the zero signals padded to the beginning and the end of the test signal (in seconds).C@*
verbose (optional): If verbose=0, no information or feedback is displayed. Otherwise, mataa_measure_signal_response prints feedback on the progress of the sound in/out. If verbose is not specified, verbose ~= 0 is assumed.@*
channels (optional): index to data channels obtained from the ADC that should be processed and returned. If not specified, all data channels are returned.@*
cal (optional): calibration data for the full analysis chain DAC / SENSOR / ADC (see mataa_signal_calibrate_DUTin and mataa_signal_calibrate_DUTout for details). If different audio channels are used with different hardware (e.g., a microphone in the DUT channel and a loopback without microphone in the REF channel), separate structs describing the hardware of each channel can be provided in a cell array. If no cal is given or cal = [], the data will not be calibrated.@*
X0_unit (optional): unit of test signal data in X0 (string):@*
If unit = 'digital' (default): X0 signal is given in digital domain. The X0 values are sent to the DAC without any amplitude conversion. X0 values are allowed to range from -1 to +1, corresponding to the min. and max. value of the analog signal at the DAC output.@*
If unit = unit of the sensitivity value specified in the cal data for the DAC analog output signal (e.g., unit = 'V': X0 signal is given in the physical units of the ; X0 reflects the signal voltage that is generated at the DAC output. The X0 voltages are converted to "digital domain values" using the DAC sensitivity given in the 'cal' data before the data is sent the DAC. X0 values are allowed to range from the min. to max. voltages that can be generated by the DAC output.@*

OUTPUT:@*
dut_out: matrix containing the signal(s) at the DUT output(s) / SENSOR input(s) (all channels used for signal recording, each colum corresponds to one channel). If SENSOR and ADC cal data are available, these data are calibrated for the input sensitivity of the SENSOR and ADC.@*
dut_in: matrix containing the signal(s) at the DAC(+BUFFER) output(s) / DUT input. If DAC cal data are available, these data are calibrated for the output sensitivity of the DAC(+BUFFER). This may also be handy if the original test-signal data are stored in a file, which would otherwise have to be loaded into into workspace to be used.@*
t: vector containing the times corresponding the samples in dut_out and dut_in (in seconds)@*
dut_out_unit: unit of data in dut_out. If the signal has more than one channel, signal_unit is a cell string with each cell reflecting the units of each signal channel.@*
dut_in_unit: unit of data in dut_in (analogous to dut_out_unit)@*
X0_RMS: RMS amplitude of signal at DUT input / DAC(+BUFFER) output (same unit as dut_in data). This may be different from the RMS amplitude of dut_in due to the zero-padding of dut_in in order to accomodate for the latency of the analysis system; the X0_RMS value is determined from the test signal before zero padding.@*


NOTES:@*

(1) As a general rule, the number of DAC channels (X0) and the number of ADC channels ('channels' index) must be the same:@*
* In many situations the optional 'channels' index for the ADC channels can be omitted or left empty (channels=[]). The index will then be set automatically to channels = [1:size(X0,2)] (i.e., the ADC channel numbers correspond to the DAC channel numbers). @*
* Some audio interfaces have more ADC channels than DAC channels, so it is necessary to explicitly specify which ADC channels are used. Example for an audio interface with 2 DACs and 4 ADCs: using X0 with two channels (size(X0,2)=2) requires two ADC channels. If channels = [], ADC channels 1 and 2 will be used automatically. To use ADC channels 3 and 4 instead, set channels=[3,4].@*
* If cal data is specified, each channel needs its own cal data, so length(cal) = size(X0,2). If cal is not specified, the cal data for each channel will be set to cal{k}=[], and the data will remain uncalibrated.@*

(2) If the DAC output is specified as "digital" (no physical unit for X0 data), the signal samples may range from -1.0 to +1.0.@*


EXAMPLES:@*

(1) Feed a 1 kHz sine-wave signal to the DUT and plot the DUT output (no data calibration):@*
> fs = 44100;@*
> [s,t] = mataa_signal_generator ('sine',fs,0.2,1000);@*
> [out,in,t,out_unit,in_unit] = mataa_measure_signal_response(s,fs,0.1,1,1);@*
> plot (t,out);@*
> xlabel ('Time (s)')@*

(2) Feed a 1 kHz sine-wave signal with a 1.8 Volt amplitude (zero-to-peak) to the DUT, use calibration as in GENERIC_CHAIN_DIRECT.txt file, and compare the input and response signals:@*
> fs = 44100;@*
> [s,t] = mataa_signal_generator ('sine',fs,0.2,1000);@*
> [out,in,t,out_unit,in_unit] = mataa_measure_signal_response(1.8*s,fs,0.1,1,1,'GENERIC_CHAIN_DIRECT.txt','V');@*
> subplot (2,1,1); plot (t,in); ylabel (sprintf('Signal at DUT input (%s)',in_unit));@*
> subplot (2,1,2); plot (t,out); ylabel (sprintf('Signal at DUT output (%s)',out_unit));@*
> xlabel ('Time (s)')@*


@findex mataa_measure_sine_distortion
@node mataa_measure_sine_distortion
@section mataa_measure_sine_distortion

file: ...mataa_tools/mataa_measure_sine_distortion.m@*

function [L,f,fi,L0,unit] = mataa_measure_sine_distortion (fi,T,fs,latency,cal,amplitude,unit,window,N_avg);@*

DESCRIPTION:@*
Play sine signals with frequencies fi and return the spectrum of the resulting signal in the DUT channel (e.g., measure harmonic distortion spectrum, or intermodulation distortion spectrum).@*

INPUT:@*
fi: base frequency in Hz (if fi is a scalar), or frequency values of simultaneous sine signals (if fi is a vector).@*
T: length of sine signal in seconds.@*
fs: sampling frequency in Hz@*
latency (optional): see mataa_measure_signal_response (default: latency = [])@*
cal (optional): calibration data for data calibration (see mataa_signal_calibrate for details).@*
amplitude and unit (optional): amplitude and unit of test signal at DUT input (see mataa_measure_signal_response). Note that the 'unit' controls the amplitude of the analog signal at the DUT input. Default: amplitude = 1, unit = 'digital'@*
window (optional): window function to be applied to the DUT response before calculating the spectrum (default: window = 'none'). See also mataa_signal_window(...). If the window function requires additional parameter, then window can be given as a struct with three fields corresponding to the mataa_signal_window(...) arguments as follows:@*
window.name = 'window' input argument of mataa_signal_window(...)@*
window.par  = 'par' input argument of mataa_signal_window(...)@*
	window.len  = 'len' input argument of mataa_signal_window(...) @*
N_avg (optional): number of averages (integer, default: N_avg = 1). If N_avg > 1, the measurement is repeated N_avg times, and the mean result is returned. This is useful to reduce the noise floor.@*

OUTPUT:@*
L: spectrum of DUT output signal at frequency values f. L(:,1) = amplitudes (zero-to-peak), L(:,2) = phase angles (radian)@*
f: frequency values of spectrum (Hz).@*
fi: frequency value(s) of fundamental(s)they may have been adjusted to align with the frequency resolution of the spectrum to avoid frequency leakage)@*
L0: signal level of fundamental(s) (useful for normalising plots)@*
unit: unit of data in L and L0.@*

EXAMPLE-1 (distortion spectrum from 1000 Hz fundamental, with 1.0 V-pk amplitude test signal):@*
> [L,f,fi,L0,unit] = mataa_measure_sine_distortion (1000,1,44100,0.2,'GENERIC_CHAIN_DIRECT.txt',1.0,'V','flattop'); % perform measurement with 1V-pk test signal@*
> loglog (f,L); xlabel ('Frequency (Hz)'); ylabel(sprintf('Amplitude (%s)',unit)); % plot result@*

EXAMPLE-2 (IM distortion spectrum from 10000 // 11000 Hz fundamentals):@*
> [L,f,fi,L0] = mataa_measure_sine_distortion ([10000 11000],10,44100,0.2); % perform measurement@*
> loglog (f,L/L0*100); xlabel('Frequency (Hz)'); ylabel('Amplitude rel. fundamentals (%)'); % plot result@*


@findex mataa_menu
@node mataa_menu
@section mataa_menu

file: ...mataa_tools/mataa_menu.m@*

function out = mataa_menu (title, varargin)@*

DESCRIPTION:@*
This function prints a menu and asks the user to choose a command from the menu.@*

title: the tile of the menu (string)@*
varargin: a list of menu entries as described in the below example@*
out: the command chosen by the user@*

EXAMPLE:@*

To print a menu with the title 'Main menu' and the commands 'measure', 'plot', 'save' and 'exit':@*
choice = mataa_menu('Main menu','m','measure','p','plot','s','save','e','exit');@*

The result will look like this:@*
-----------@*
    Main menu:@*
    [m] measure  --  [p] plot  --  [s] save  --  [e] exit@*
    @*
    Choose a command: @*
-----------@*
The user then chooses one of the four commands by entering 'm', 'p', 's' or 'e'. If he/she enteres something else, an error message will be shown, and the menu is displayed again.@*


@findex mataa_minimum_phase
@node mataa_minimum_phase
@section mataa_minimum_phase

file: ...mataa_tools/mataa_minimum_phase.m@*

function min_phase = mataa_minimum_phase (mag,f);@*

DESCRIPTION:@*
Calculates minimum phase from magnitude frequency response using the Hilbert transform (see http://en.wikipedia.org/wiki/Minimum_phase#Relationship_of_magnitude_response_to_phase_response).@*


INPUT:@*
mag: magnitude of frequency response (in dB)@*
f: frequency coordinates of mag (in Hz)@*

OUTPUT:@*
min_phase: minimum phase at frequnecies f (unwrapped, in degrees)@*

%%    % calculate minimum phase using the Hilbert transform:@*
%%    % see: http://www.fourelectronics.com/Hilbert-transform-to-calculate-Magnitude-from-Phase-10052397.html@*
%%    % and: http://www.dsprelated.com/showmessage/29416/1.php@*
%%    % this should use the NATURAL log, and 'abs(p)' rather than '10*abs(p)'!@*
convert mag from dB to natural units:@*

@findex mataa_octave_version
@node mataa_octave_version
@section mataa_octave_version

file: ...mataa_tools/mataa_octave_version.m@*

function [version,subversion,subsubversion] = mataa_octave_version@*

DESCRIPTION:@*
Returns the Octave version. If called with Matlab, the output values are set to NaN.@*

INPUT:@*
(none)@*

OUTPUT:@*
version: main version@*
subversion: subversion@*
subsubversion: subsubversion@*

EXAMPLE:@*
With Octave 2.1.73, the output is:@*
version = 2@*
subversion = 1@*
subsubversion = 73@*


@findex mataa_path
@node mataa_path
@section mataa_path

file: ...mataa_tools/mataa_path.m@*

function pth = mataa_path (whichPath);@*

DESCRIPTION:@*
This function returns the Matlab / MATAA paths as specified by 'whichPath'@*

INPUT:@*
whichPath (optional): a string specifying which path should be retrieved.@*
whichPath can be one of the following:@*
'main' (default)   the main MATAA path@*
'signals'          the path where the test signal data is stored@*
'tools'            the path where the MATAA 'tools' routines are stored (the MATAA toolbox)@*
'TestTone'         the path to the TestTone program@*
'TestDevices'      the path to the TestDevices program@*
'mataa_scripts'    the path to the MATAA scripts@*
'microphone'       the path to the microphone-data files - THIS IS DEPRECATED! The 'microphone' identifier is now mapped to the 'calibration' identifier.@*
'settings'	     the path where the MATAA settings are stored@*
'calibration'      the path where calibration files are stored (microphones, audio interfaces / soundcards, etc.)@*

If whichPath is not specified, it is set to 'main' by default.@*

OUTPUT:@*
pth: the MATAA path as indicated by whichPath (string)@*


@findex mataa_phase_remove_delay
@node mataa_phase_remove_delay
@section mataa_phase_remove_delay

file: ...mataa_tools/mataa_phase_remove_delay.m@*

function [phase,f] = mataa_phase_remove_delay (phase,f,delay);@*

DESCRIPTION:@*
This function removes excess phase due to time delay.@*

INPUT:@*
phase: phase, including excess phase due to time delay (unwrapped, in degrees)@*
f: frequency coordinates of phase (in Hz)@*
delay: time delay to be removed from the phase (in seconds)@*

OUTPUT:@*
phase: phase with excess phase corresponding to delay removed (unwrapped, in degrees)@*


@findex mataa_phase_remove_trend
@node mataa_phase_remove_trend
@section mataa_phase_remove_trend

file: ...mataa_tools/mataa_phase_remove_trend.m@*

function [phase,delay] = mataa_phase_remove_trend (phase,f,f1,f2);@*

DESCRIPTION:@*
Remove linear trend in phase(f), e.g. excess phase due to time delay.@*

INPUT:@*
phase: phase, including excess phase due to time delay (unwrapped, in degrees)@*
f: frequency coordinates of phase (in Hz)@*
f1, f2 (optional, in Hz): if both f1 and f2 are specified, the linear trend in phase(f1<f<f2) is removed from phase(f). If both f1 and f2 are not specified, the full range of f is used from trend analysis.@*

OUTPUT:@*
phase: phase with excess phase corresponding to delay removed (unwrapped, in degrees)@*
delay: time delay corresponding the the removed phase trend (in seconds)@*

EXAMPLE (remove excess phase and determine "flight time" of impulse response):@*
[h,t,unit] = mataa_IR_demo ('FE108'); % load impulse response@*
[mag,phase,f] = mataa_IR_to_FR(h,t,[],unit); % convert to frequency domain@*
min_phase = mataa_minimum_phase (mag,f); % determine minimum phase (in degrees)@*
ex_phase = phase - min_phase; % determine excess phase (phase = minimum-phase + excess-phase)@*
[u,delay] = mataa_phase_remove_trend (ex_phase,f,1400,5000); % determine exess phase trend (ex_phase = -2pi x delay), and determine delay = "flight time"@*


@findex mataa_plot_CSDt
@node mataa_plot_CSDt
@section mataa_plot_CSDt

file: ...mataa_tools/mataa_plot_CSDt.m@*

function mataa_plot_CSDt (spl,f,t,spl_range,annote,opts);@*

DESCRIPTION:@*
Plot cumulative spectral decay (CSD) data from mataa_IR_to_CSD(...) in a 3D diagram using slices of constant time t ('waterfall plot'). The argument 'annote' is optional, and can be used to specify annotations to be added to the titles of the plots.@*

INPUT:@*
spl,f,t: see description of output of mataa_IR_to_CSD@*
spl_range: the range covered on the y axis of the waterfall diagram (in dB)@*
annote: annotations to the plot title (string, optional)@*
opts: plot opts (sting or cell string containing multiple opts, optional). Currently, the following opts are available (for Octave 2.9.10 or newer):@*
    opts = 'contours' : plot contours of waterfall diagram below the waterfall@*
    opts = 'countours2': plot contours (lines) only in a 2-D plot@*
    opts = 'shaded2': similar to 'contours2', but fills the areas in between the contours with a solid color)@*

EXAMPLE:@*
[h,t] = mataa_IR_demo ('FE108');@*
T = [0:1E-4:4E-3];@*
[spl,f,t] = mataa_IR_to_CSD (h,t,T,1/24);@*
mataa_plot_CSDt (spl,f,t,50);@*


@findex mataa_plot_defaults
@node mataa_plot_defaults
@section mataa_plot_defaults

file: ...mataa_tools/mataa_plot_defaults.m@*

function mataa_plot_defaults@*

DESCRIPTION:@*
In earlier version of MATAA, this function sets default gnuplot state for MATAA plots in Octave. With the current version of MATAA, this function has no effect.@*

HISTORY:@*
26. December 2007 (Matthias Brennwald): commented out all commands so they have no effect anymore. Leave setting of plotting options to the user.@*
first version: 7. November 2006, Matthias Brennwald@*
%% if exist('OCTAVE_VERSION')@*
%%     % do Octave specific stuff here@*
%% else@*
%%     % do Matlab specific stuff here@*
%%     %%% fh = gcf;@*
%%     %%% p = get(fh,'Position');@*
%%     %%% if p([3,4]) == [560   420];@*
%%     %%%     % make plots somewhat smaller than default@*
%%     %%%     p([3,4]) = [450   280];@*
%%     %%%     set(fh,'Position',p); @*
%%     %%% end@*
%%     %%% set(fh,'PaperPositionMode','auto'); % use same plot size for saving files as for plotting on screen@*
%% end@*
%% if mataa_settings('plotHoldState')@*
%%     hold on@*
%% end@*
%% @*
%% % otherwise leave the plot state as it is (the user may have typed 'hold on' or something@*

@findex mataa_plot_ETC_dB
@node mataa_plot_ETC_dB
@section mataa_plot_ETC_dB

file: ...mataa_tools/mataa_plot_ETC_dB.m@*

function mataa_plot_ETC_log (etc,t,annote,dB_range);@*

DESCRIPTION:@*
Same as mataa_plot_ETC, but uses a dB scale for the vertical axis.@*
The 'dB_range' parameter (optional) can be given to specify the dB range to be plotted. If not specified, a default value of 60 dB is used@*


@findex mataa_plot_ETC_lin
@node mataa_plot_ETC_lin
@section mataa_plot_ETC_lin

file: ...mataa_tools/mataa_plot_ETC_lin.m@*

function mataa_plot_ETC_lin (etc,t,annote);@*

DESCRIPTION:@*
Plots the energy-time-curve (ETC) etc(t), using a linear y-axis scale.@*

INPUT:@*
etc: values of the energy-time curve (vector)@*
t: time values (vector)@*
annote (optional): annotation to the plot title (string)@*

OUTPUT:@*
(none)@*

EXAMPLE:@*
> t = [0:100]/1000; h = sin(200*t).*exp(-70*t);@*
> etc = mataa_IR_to_ETC(h,t);@*
> mataa_plot_ETC(t,etc, 'damped sine');@*


@findex mataa_plot_FR
@node mataa_plot_FR
@section mataa_plot_FR

file: ...mataa_tools/mataa_plot_FR.m@*

function mataa_plot_FR (mag,phase,f,annote,fNorm,phaseUnwrap);@*

DESCRIPTION:@*
Plots frequency response magnitude, and phase (optional)@*

INPUT:@*
mag: magnitude of frequency response (in dB)@*
phase (optional): phase of frequency response (in degrees). If you don't want to plot phase, but other optional arguments below are required, use phase = [].@*
f: frequency coordinates of mag and phase (in Hz)@*
annote (optional): text note to be added to the plot title. If you don't want to add a note, but other optional arguments below are required, use annote = ''.@*
fNorm (optional): frequency to which the magnitude plot is normalised. If you don't want to normalise the plot, but other optional arguments below are required, use fNorm = [].@*
phaseUnwrap (optional): if phaseUnwrap is not zero, the phase is unwraped (so that discontinuities at +/- 180 deg. are avoided). Otherwise, phase is wrapped to +/- 180 deg.@*

EXAMPLE(S):@*
> [h,t] = mataa_IR_demo; @*
> [mag,phase,f] = mataa_IR_to_FR(h,t,1/12);@*
> mataa_plot_FR(mag,[],f); % plain vanilla plot of magnitude vs. frequency (without phase)@*
> mataa_plot_FR(mag,[],f,'demo',1000); % plots magnitude with an annotation to the plot title and normalizes mag by mag(f=1000).@*
> mataa_plot_FR(mag,phase,f,'demo again',80,1); % plots magnitude and phase with an annotation to the plot title. Magnitude is normalised such that mag(f=80) = 0 dB, and phase is unwrapped.@*


@findex mataa_plot_HD
@node mataa_plot_HD
@section mataa_plot_HD

file: ...mataa_tools/mataa_plot_HD.m@*

function mataa_plot_HD (kn, annote);@*

DESCRIPTION:@*
This function plots the harmonic distortion spectrum in kn.@*

INPUT:@*
kn = [ k1 k2 k3 ... kn ] is the normalised distortion spectrum.@*
k1 corresponds to the fundamental frequency or first harmonic (k1 = 1, not plotted), k2 the component of second harmonic relative to the fundamental, k3 that of the third harmonic, etc.@*
annote (optional): optional annotation to be added to the plot title@*

EXAMPLE:@*
> HD = mataa_measure_HD_noise ( 1000,1,44100,10,0.2 ); % measure harmonic distortion spectrum@*
> mataa_plot_HD(HD(1,:),'f0: 1kHz'); % plot the distortion spectrum@*


@findex mataa_plot_impedance
@node mataa_plot_impedance
@section mataa_plot_impedance

file: ...mataa_tools/mataa_plot_impedance.m@*

function mataa_plot_impedance (mag,phase,f,annote);@*

DESCRIPTION:@*
Plots impedance (magnitude and phase) versus frequency.@*

INPUT:@*
mag: impedance magnitude (Ohm)@*
phase: impedance phase (degrees)@*
f: frequency (Hz)@*
annote (optional): text note to be added to the plot title.@*

OUTPUT:@*
(none)@*


@findex mataa_plot_IR
@node mataa_plot_IR
@section mataa_plot_IR

file: ...mataa_tools/mataa_plot_IR.m@*

function mataa_plot_IR (h,t,annote);@*

DESCRIPTION:@*
This function plots the impulse response h(t).@*

INPUT:@*
h: impulse response samples@*
t: time coordinates of impulse response samples (vector, in seconds), or, alternatively, the sampling frequency of h(t) (scalar, in Hz)@*
annote (optional): text note to be added to the plot title.@*

EXAMPLE:@*
> [h,t] = mataa_IR_demo;@*
> mataa_plot_IR(h,t,'demo impulse response');@*


@findex mataa_plot_one
@node mataa_plot_one
@section mataa_plot_one

file: ...mataa_tools/mataa_plot_one.m@*

function h = mataa_plot_one (x,y,figNum,plottit,xtit,ytit);@*

DESCRIPTION:@*
Plots y vs. x.@*

INPUT:@*
x: x values@*
y: y values to be plotted vs. x.@*
figNum: number (handle) of the figure window to be used for the plot. Use figNum = [] if the default window is to be used (e.g. the current plot window)@*
plottit: plot title.@*
xtit: x-axis label@*
ytit: y-axis label@*

OUTPUT:@*
h: handle to the axes of the plot.@*


@findex mataa_plot_save
@node mataa_plot_save
@section mataa_plot_save

file: ...mataa_tools/mataa_plot_save.m@*

function mataa_plot_save (fileName);@*

DESCRIPTION:@*
Saves the last plot to an EPS (encapsulated post script) file.@*
'fileName' is the name (and path) of the file. If it does not include a path, the file is saved to the current directory (type 'pwd' to see the current directory).@*


@findex mataa_plot_SR
@node mataa_plot_SR
@section mataa_plot_SR

file: ...mataa_tools/mataa_plot_SR.m@*

function mataa_plot_SR (h,t,annote);@*

DESCRIPTION:@*
This function plots the step response h(t).@*

INPUT:@*
h: step response samples@*
t: time coordinates of response response samples (vector), or, alternatively, the sampling frequency of h(t) (scalar)@*
annote (optional): text note to be added to the plot title.@*

EXAMPLE:@*
> [h,t] = mataa_IR_demo;@*
> [h,t] = mataa_IR_to_SR(h,t);@*
> mataa_plot_SR(h,t,'demo step response');@*


@findex mataa_plot_TBESf
@node mataa_plot_TBESf
@section mataa_plot_TBESf

file: ...mataa_tools/mataa_plot_TBESf.m@*

function mataa_plot_TBESf (f,tau,A,ARange,tauRange,annote);@*

DESCRIPTION:@*
Plot tone burst energy storage data (as obtained from mataa_IR_to_TBES(...) in a 3D diagram using slices of constant frequency t.@*

INPUT:@*
f,tau,A: see description of output of mataa_IR_to_TBES@*
ARange: range of A axis@*
annote: annotations to the plot title (string, optional)@*

EXAMPLE:@*
> [h,t] = mataa_IR_demo ('FE108');@*
> f = logspace (2,4,50);@*
> [A,tau,f] = mataa_IR_to_TBES (h,t,f);@*
> mataa_plot_TBESf (f,tau,A,40,8,'FE108');@*


@findex mataa_plot_time_signal
@node mataa_plot_time_signal
@section mataa_plot_time_signal

file: ...mataa_tools/mataa_plot_time_signal.m@*

function mataa_plot_time_signal (s,t,plottit,xtit,ytit,plotWindow);@*

DESCRIPTION:@*
This function plots the signal s(t).@*

INPUT:@*
s: signal samples@*
t: time values (vector, in seconds), or, alternatively, the sampling frequency of the signal (scalar, in Hz)@*
plottit: plot title.@*
xtit, ytit: labels for the x-axis and y-axis@*
plotWindow: number (handle) of the figure window to be used for the plot. Use plotWindow = [] if the default window is to be used (e.g. the current plot window)@*


@findex mataa_plot_two_logX
@node mataa_plot_two_logX
@section mataa_plot_two_logX

file: ...mataa_tools/mataa_plot_two_logX.m@*

function h = mataa_plot_two_log (x,y1,y2,figNum,plottit,xtit,y1tit,y2tit);@*

DESCRIPTION:@*
Same as mataa_plot_two, but with logarithmic x axes.@*

INPUT:@*
(see mataa_plot_two)@*

OUTPUT:@*
(see mataa_plot_two)@*


@findex mataa_plot_two
@node mataa_plot_two
@section mataa_plot_two

file: ...mataa_tools/mataa_plot_two.m@*

function h = mataa_plot_two (x,y1,y2,figNum,plottit,xtit,y1tit,y2tit);@*

DESCRIPTION:@*
Plots y1 and y2 vs. x.@*

INPUT:@*
x: x values@*
y1, y2: y values to be plotted vs. x. y2 may be empty (y2 = []), which will result in a single plot of y1 vs x.@*
figNum: number (handle) of the figure window to be used for the plot. Use figNum = [] if the default window is to be used (e.g. the current plot window)@*
plottit: plot title.@*
xtit: x-axis label@*
y1tit, y2tit: y-axis label of the y1 and y2 data@*

OUTPUT:@*
h: a 2-vector containig the handles to the axes of the two plots. If the second plot is omitted h(2) will be set to NaN,@*


@findex mataa_realFT0
@node mataa_realFT0
@section mataa_realFT0

file: ...mataa_tools/mataa_realFT0.m@*

function [S,f] = mataa_realFT0 (s,t);@*

DESCRIPTION:@*
Calculates the complex fourier-spectrum S of a real signal s for frequencies f >= 0. Only the half spectrum corresponding to positive frequencies is returned, because for a real signal S(-f)=S*(f). This implies that the RMS level of S is only half the RMS level of the full (symmetric) Fourier spectrum.@*
s can be of any length (no padding to length of 2n or even length necessary). In order to avoid frequency leakage, mataa_realFT does NOT pad s to even length. Each column of s represents one audio channel.@*

INPUT:@*
s: signal samples (vector containing the real-valued samples)@*
t: time values of the signal samples (vector, with evenly spaced values) or sample rate (scalar)@*

OUTPUT:@*
S: complex fourier spectrum of s ('positive' half, see also DESCRIPTION).@*
f: frequency values (vector)@*


@findex mataa_realFT
@node mataa_realFT
@section mataa_realFT

file: ...mataa_tools/mataa_realFT.m@*

function [S,f] = mataa_realFT (s,t);@*

DESCRIPTION:@*
Identical to mataa_realFT0, but without the component corresponding to f=0.@*

INPUT:@*
(see mataa_realFT0)@*

OUTPUT:@*
(see mataa_realFT0)@*


@findex mataa_realIFT0
@node mataa_realIFT0
@section mataa_realIFT0

file: ...mataa_tools/mataa_realIFT0.m@*

function [s,t] = mataa_realIFT0 (S,f);@*

DESCRIPTION:@*
Calculates the inverse Fourier transform of a spectrum S(f) of a signal with real-valued samples. Only the 'positive' half of the spectrum is used, i.e. only positive frequencies (including f=0) must be given as input. See also mataa_realFT0.@*

INPUT:@*
S: complex fourier spectrum of the signal ('positive' half, see also DESCRIPTION).@*
f: frequency values (vector)@*

OUTPUT:@*
s: signal samples (real-valued samples)@*
t: time values of the signal@*


@findex mataa_realIFT
@node mataa_realIFT
@section mataa_realIFT

file: ...mataa_tools/mataa_realIFT.m@*

function [s,t] = mataa_realIFT (S,f);@*

DESCRIPTION:@*
Same as mataa_realIFT0, but without f=0.@*

INPUT:@*
S: complex fourier spectrum of the signal ('positive' half, see also DESCRIPTION).@*
f: frequency values (vector)@*

OUTPUT:@*
s: signal samples (real-valued samples)@*
t: time values of the signal@*


@findex mataa_running_mean
@node mataa_running_mean
@section mataa_running_mean

file: ...mataa_tools/mataa_running_mean.m@*

function y = mataa_running_mean (x,n,w);@*

DESCRIPTION:@*
Returns a running mean of a data series x.@*

INPUT:@*
x: vector conaining the original data series@*
n: width of the smoothing window (number of samples, should be an odd number, n > 0)@*
w (optional): name of window type to be used. Default is 'rectangular', for other window types see mataa_signal_window@*

OUTPUT:@*
y: running mean of y, length(ym) = length(y)@*

EXAMPLE:@*
> N=1000; f0=500; fs=96000; t=[0:N-1]/fs; s = sin(2*pi*f0*t); % prepare a 500-Hz sine@*
> x = s+randn(size(s))/10;                % create a noisy version of s@*
> y = mataa_running_mean(x,41,'hamm');      % remove the noise using a 41 samples wide Hamming window@*
> plot(t,x,'k',t,s,'g',t,y,'r')           % plot the different versions of s@*


@findex mataa_select_signal_window_time
@node mataa_select_signal_window_time
@section mataa_select_signal_window_time

file: ...mataa_tools/mataa_select_signal_window_time.m@*

function [t_start,t_end] = mataa_select_signal_window_time;@*

DESCRIPTION:@*
Interactively select start and end times of a signal.@*

INPUT:@*
(none)@*

OUTPUT:@*
t_start: start of selected signal range@*
t_end: end of selected signal range@*

input('Make shure that the window showing the signal-plot is active, and the zoom is set accordingly (press ENTER to confirm)...')@*

@findex mataa_settings
@node mataa_settings
@section mataa_settings

file: ...mataa_tools/mataa_settings.m@*

function val = mataa_settings (field,value)@*

DESCRIPTION:@*
Retrieve and set MATAA settings.@*

mataa_settings with no arguments returns all the settings@*
mataa_settings(field) returns the value of the setting of 'field'@*
mataa_settings(field,val) sets the value of the setting 'field' to 'val'.@*
mataa_settings('reset') resets the settings to default values@*

EXAMPLES:@*
** get the current settings (this also shows you the available fields):@*
> mataa_settings@*

** get the current plot color:@*
> mataa_settings('plotColor')@*

** set the plot color to red:@*
> mataa_settings('plotColor','r')@*

** In principle, you can store anything in the MATAA settings file. For instance, you can store the birhtday of your grandmother, so you'll never forget that:@*
> mataa_settings('BirthdayOfMyGrandmother','1st of April 1925');@*


@findex mataa_signal_analytic
@node mataa_signal_analytic
@section mataa_signal_analytic

file: ...mataa_tools/mataa_signal_analytic.m@*

function a = mataa_signal_analytic (s);@*

DESCRIPTION:@*
Calculate analytic signal a of signal s.@*

INPUT:@*
s: vector containing the samples values of the signal.@*

OUTPUT:@*
a: vector containing the analytic signal of s.@*

EXAMPLE:@*
calculate the amplitude envelope of the impulse response of a loudspeaker@*
> [h,t] = mataa_IR_demo;        % load demo impulse response@*
> a = mataa_signal_analytic(h); % calculate analytic response@*
> a = abs(a);                   % abs(a) is the amplitude envelope of impulse response@*
> plot(t,a);@*
 @*

@findex mataa_signal_autocorr
@node mataa_signal_autocorr
@section mataa_signal_autocorr

file: ...mataa_tools/mataa_signal_autocorr.m@*

function [c,T] = mataa_signal_autocorr (s,t);@*

DESCRIPTION:@*
Autocorrelation c(T) of signal s(t), for positive delays (T>=0).@*

INPUT:@*
s: vector containing the samples values of the signal.@*
t: time values of the signal samples (vector, in seconds, with evenly spaced values) or sample rate (scalar, in Hz).@*

OUTPUT:@*
c: vector containing the autocorrelation of s.@*
T: time lag (vector).@*


@findex mataa_signal_calibrate_DUTin
@node mataa_signal_calibrate_DUTin
@section mataa_signal_calibrate_DUTin

file: ...mataa_tools/mataa_signal_calibrate_DUTin.m@*

function [s_cal,t,s_cal_unit] = mataa_signal_calibrate_DUTin (s,t,cal,verbose)@*

DESCRIPTION:@*
This function calibrates the signal s(t) at the input of a DUT using the given DAC(+BUFFER) calibration data, and it will also (try to) determine the unit of the calibrated data. In other words, this function "converts" the raw data sent to the sound inteface (DAC) to the physical signal at the DAC(+BUFFER) output as seen by the DUT. See illustration below.@*

If s has more than one channel, different calibration information can be specified for the different channels.@*

See also mataa_load_calibration and mataa_signal_calibrate_DUTin.@*

  ILLUSTRATION (example with loudspeaker/DUT tested using a microphone):@*

  MATAA / COMPUTER ----> DAC (+BUFFER) ---->    DUT     ---->   SENSOR  ---->  ADC (+PREAMP) ----> MATAA / COMPUTER@*
   (dimensionless)      (dim.less -> V)      (V -> Pa)         (Pa -> V)      (V -> dim.less)      (dimensionless)@*

      ===> unit of DUT output / sensor input signal (h_cal) is Pa@*

INPUT:@*
s: signal samples (unit: dimensionless data as obtained by ADC / soundcard)@*
t: time coordinates of samples in h (vector, in seconds) or sampling rate of h (scalar, in samples per second)@*
cal: name of calibration file or calibration data (struct object as obtained from mataa_load_calibration). cal struct must contain DAC field. For calibration of more than one data channels, cal can be specified as a cell array, whereby each cell element is used for the corresponding data channel.@*
verbose (optional): flag to control verbosity (bool, default: verbose = false)@*

OUTPUT:@*
s_cal: calibrated signal@*
t: time coordinates of samples in h@*
s_cal_unit: unit of h_cal (string), i.e. the unit of the calibrated DUT signal@*

EXAMPLE@*
Feed a 1 kHz sine-wave signal to the DUT and measure the raw response signal without calibration; then calibrate raw data according to GENERIC_CHAIN_DIRECT.txt cal file:@*
> fs = 44100;@*
> [s,t] = mataa_signal_generator ('sine',fs,0.2,1000);@*
> [out,in,t,out_unit,in_unit] = mataa_measure_signal_response(s,fs,0.1,1,1);@*
> [X,t_X,unit_X] = mataa_signal_calibrate_DUTin (in,t,'GENERIC_CHAIN_DIRECT.txt'); % calibrate signal at DUT input / DAC(+BUFFER) output@*
> [Y,t_Y,unit_Y] = mataa_signal_calibrate_DUTout (out,t,'GENERIC_CHAIN_DIRECT.txt'); % calibrate signal at DUT out / ADC input@*
> subplot (2,1,1); plot (t_X,X); ylabel (sprintf('Signal at DUT input (%s)',unit_X));@*
> subplot (2,1,2); plot (t_Y,Y); ylabel (sprintf('Signal at DUT output (%s)',unit_Y));@*
> xlabel ('Time (s)')@*


@findex mataa_signal_calibrate_DUTout
@node mataa_signal_calibrate_DUTout
@section mataa_signal_calibrate_DUTout

file: ...mataa_tools/mataa_signal_calibrate_DUTout.m@*

function [s_cal,t,s_cal_unit] = mataa_signal_calibrate_DUTout (s,t,cal,verbose)@*

DESCRIPTION:@*
This function calibrates the signal s(t) at the output of a DUT using the given calibration data (e.g., for a specific audio interface, microphone, sensor, etc), and it will also (try to) determine the unit of the calibrated data. In other words, this function "converts" the raw data recorded by the sound inteface (ADC) to the physical signal seen by the sensor (e.g., by a measurement microphone). See illustration below.@*

If the transfer function of the analytical chain (sensor, microphone, etc.) given in the cal data is specified using magnitude only (i.e, without phase information), the phase of the transfer function is calculated by assuming a minimum phase system (for example, if the transfer function of a measurement microphone is given by magnitude, it's phase is determined by assuming minimum phase). The DUT response signal is then compensated for the full transfer function taking into account both magnitude and phase.@*

If s has more than one channel, different calibration information can be specified for the different channels.@*

See also mataa_load_calibration and mataa_signal_calibrate_DUTin.@*

  ILLUSTRATION (example with loudspeaker/DUT tested using a microphone):@*

  MATAA / COMPUTER ----> DAC (+BUFFER) ---->    DUT     ---->   SENSOR  ---->  ADC (+PREAMP) ----> MATAA / COMPUTER@*
   (dimensionless)      (dim.less -> V)      (V -> Pa)         (Pa -> V)      (V -> dim.less)      (dimensionless)@*

      ===> unit of DUT output / sensor input signal (h_cal) is Pa@*

INPUT:@*
s: signal samples (unit: dimensionless data as obtained by ADC / soundcard)@*
t: time coordinates of samples in h (vector, in seconds) or sampling rate of h (scalar, in samples per second)@*
cal: name of calibration file (e.g., 'Behringer_ECM8000_transfer.txt') or calibration data (struct object as obtained from mataa_load_calibration). cal data must contain ADC and SENSOR fields. For calibration of more than one data channels, cal can be specified as a cell array, whereby each cell element is used for the corresponding data channel.@*
NOTE: for use with multiple calibration channels, the size of the cell arrays SENSOR_cal and ADC_cal must be the same@*
verbose (optional): flag to control verbosity (bool, default: verbose = false)@*

OUTPUT:@*
s_cal: calibrated signal@*
t: time coordinates of samples in h@*
s_cal_unit: unit of h_cal (string), i.e. the unit of the calibrated DUT signal@*

Feed a 1 kHz sine-wave signal to the DUT and measure the raw response signal without calibration; then calibrate raw data according to GENERIC_CHAIN_DIRECT.txt cal file:@*
> fs = 44100;@*
> [s,t] = mataa_signal_generator ('sine',fs,0.2,1000);@*
> [out,in,t,out_unit,in_unit] = mataa_measure_signal_response(s,fs,0.1,1,1);@*
> [X,t_X,unit_X] = mataa_signal_calibrate_DUTin (in,t,'GENERIC_CHAIN_DIRECT.txt'); % calibrate signal at DUT input / DAC(+BUFFER) output@*
> [Y,t_Y,unit_Y] = mataa_signal_calibrate_DUTout (out,t,'GENERIC_CHAIN_DIRECT.txt'); % calibrate signal at DUT out / ADC input@*
> subplot (2,1,1); plot (t_X,X); ylabel (sprintf('Signal at DUT input (%s)',unit_X));@*
> subplot (2,1,2); plot (t_Y,Y); ylabel (sprintf('Signal at DUT output (%s)',unit_Y));@*
> xlabel ('Time (s)')@*

helper function for calibration of various units@*

@findex mataa_signal_clipcheck
@node mataa_signal_clipcheck
@section mataa_signal_clipcheck

file: ...mataa_tools/mataa_signal_clipcheck.m@*

function n = mataa_signal_clipcheck (s,N);@*

DESCRIPTION:@*
Returns the number of samples with amplitude less than N percent% lower than the maximum amplitude of the signal (absolute values).@*

INPUT:@*
s: vector of signal samples@*
N (optional): percentage of deviation from maximum amplitude. Default value is N = 1 (i.e. 1%).@*

OUTPUT:@*
n: number of samples with amplitude less than 1% lower than the maximum amplitude of the signal (absolute values).@*

EXAMPLES:@*
* White-noise signal (not clipped):@*
> wn = mataa_signal_generator('pink',1000,1); % a white-noise signal with 1000 samples (with sample ranges distributed in the range between -1...+1).@*
> n = mataa_signal_clipcheck(wn,0.1); % find number of samples with (absolute) amplitudes that are within 0.1% of the maximum (absolute) amplitude. This will result in a low value of n (i.e. n=1, 2, or 3, but higher values are unlikely).@*

* Clipped white-noise signal:@*
> wn = 2.5*mataa_signal_generator('pink',1000,1); % a white-noise signal with 1000 samples (with sample ranges distributed in the range between -2.5...+2.5).@*
> wn(wn > 1) = 1; wn(wn < -1) = -1; % fake clipping, i.e. truncate the samples to the range (-1...+1).@*
> n = mataa_signal_clipcheck(wn,0.1); % find number of samples with (absolute) amplitudes that are within 0.1% of the maximum (absolute) amplitude. This will result in a much higher value of n than in the previous example (n ~ 200).@*

* Square-wave signal:@*
> sq = mataa_signal_generator('square',10000,0.1,1000); % a square wave signal with 1000 samples (i.e. a signal with sample values of either +1 or -1).@*
> n = mataa_signal_clipcheck(sq,0.01); % find number of samples with (absolute) amplitudes that are within 0.01% of the maximum (absolute) amplitude. This results in n=1000, because the amplitude of all samples is equal to 1.@*


@findex mataa_signal_crop
@node mataa_signal_crop
@section mataa_signal_crop

file: ...mataa_tools/mataa_signal_crop.m@*

function [s,t] = mataa_signal_crop (s,t,t_start,t_end);@*

DESCRIPTION:@*
This function crops out the part of the signal s(t) in the range t = t_start...t_end@*

INPUT:@*
s: siglal samples@*
t: time coordinates of impulse response samples (vector, in seconds), or, alternatively, the sampling frequency of s(t) (scalar, in Hz)@*

OUPTUT:@*
s: signal samples of cropped signal@*
t: time coordinates of cropped signal (in seconds)@*


@findex mataa_signal_generator
@node mataa_signal_generator
@section mataa_signal_generator

file: ...mataa_tools/mataa_signal_generator.m@*

function [s,t,info] = mataa_signal_generator (kind,fs,T,param);@*

DESCRIPTION:@*
This function creates a signal s(t) of a specified type.@*

INPUT:@*
kind:   kind of signal (see below)@*
fs:       sampling rate (in Hz)@*
T:        length of the signal (in seconds)@*
param:   Some signals require additional information, which can be specified in 'param' (a vector or structure containing the required parameters, depending on the signal kind, see below)@*

kind can be one of the following:@*
'white':            White noise (no additional parameters required)@*
'pink':             Pink noise (no additional parameters required)@*
'MLS':              Maximum length sequence (MLS). The 'T' parameter is ignored, and param = n is the number of taps to be used for the MLS. The length of the MLS will be 2^n-1 samples.@*
'sine','sin':       Sine wave (param = frequency in Hz)@*
'cosine','cos':     Cosine wave (param = frequency in Hz)@*
'sweep','sweep_log':Sine sweep, where frequency increases exponentially with time (param = [f1 f2], where f1 and f2 are the min. and max frequencies in Hz)@*
'sweep_lin':        Sine sweep, where frequency increases linearly with time (param = [f1 f2], where f1 and f2 are the min. and max frequencies in Hz)@*
'sweep_smooth','sweep_log_smooth': Same as 'sweep' and 'sweep_log', but with a smooth fade-in and fade-out (to reduce high-frequency clicks at beginning and end)@*
'stepsweep','stepsweep_log': Stepped sine sweep; a series of time-shaped sine bursts, whereby the frequency is constant throughout each burst, and increases exponentially from one burst to the next. Bursts are shaped by a Blackman envelope for smooth transition from one burst to the next. The length of each burst is such that all burst contain the same number of sine cycles. param(1): frequency of first burst, param(2): frequency of last burst, param(3): number of bursts, param(4): fractional length of burst envelope with full amplitude [optional, default value: 0.7]. info.f: frequencies of bursts, info.i_end: indices to last sample in each burst, info.Nc: number of cycles in each burst@*
'square':           Square (rectangle) wave (param = frequency in Hz)@*
'rectangle','rect:  Same as 'square'@*
'sawtooth','saw':   Sawtooth wave (param = frequency in Hz)@*
'triangle','tri':   Triangle wave (param = frequency in Hz)@*
'dirac':            Dirac signal (First sample 1, zeroes otherwise)@*
'zero':             Zero signal ('silence')@*

OUTPUT:@*
s: vector containing the signal samples (tha values in s can range from -1...+1)@*
t: vector containing the sample times (in seconds)@*
info: additional information about the signal (empty in for most signal types; see 'kind' input above).@*

Examples:@*
1. Create a 1-second pink-noise signal 96kHz sample rate:@*
> [pink,t] = mataa_signal_generator('pink',96000,1);@*
> plot(t,pink)@*

2. Create a 0.1-second 1-kHz square-wave signal with 10 kHz sample rate:@*
> [sq,t] = mataa_signal_generator('square',10000,0.1,1000);@*
> plot(t,sq)@*

3. Create a 1-kHz sine burst windowed by a Hanning window:@*
> [burst,t]=mataa_signal_generator('sin',96000,0.01,1000);@*
> burst = mataa_signal_window(burst,'hann');@*
> plot(t,burst)@*


FURTHER READING:@*
- different kinds of noise: http://en.wikipedia.org/wiki/Colors_of_noise@*
- pink noise generation: http://www.mathworks.com/matlabcentral/fileexchange/loadFile.do?objectId=5091&objectkind=FILE@*
- sine sweeps (chirp signals): http://en.wikipedia.org/wiki/Chirp@*


@findex mataa_signal_pad_Zeros
@node mataa_signal_pad_Zeros
@section mataa_signal_pad_Zeros

file: ...mataa_tools/mataa_signal_pad_Zeros.m@*

function [s,t] = mataa_signal_pad_Zeros (s0,t0,T);@*

DESCRIPTION:@*
This function pads a signal s0(t0) with zeroes, i.e. replaces signal s0(t0) with s(t), where...@*
...s(t=t0) = s0(t0)@*
...s(t>max(t0) and t<T) = 0@*

The new signal s(t) therefore has length T@*


@findex mataa_signal_removeHF
@node mataa_signal_removeHF
@section mataa_signal_removeHF

file: ...mataa_tools/mataa_signal_removeHF.m@*

function [s,t] = mataa_signal_removeHF (s,t,fc);@*

DESCRIPTION:@*
Removes signal components with frequencies higher than fc from s(t) by repeated convolution of s with a Hann window.@*

INPUT:@*
s: signal samples@*
t: time (vector, in seconds) or sampling frequency (scalar, in Hz)@*
fc: cut-off frequency (in Hz)@*

OUTPUT:@*
s: filtered signal samples@*
t: time@*


@findex mataa_signal_save
@node mataa_signal_save
@section mataa_signal_save

file: ...mataa_tools/mataa_signal_save.m@*

function mataa_signal_save (s,fs,file,description);@*

DESCRIPTION:@*
Saves the signal s(t) to an binary file (Matlab 6 format).@*

INPUT:@*
...@*

OUTPUT:@*
...@*


@findex mataa_signal_spectrogram
@node mataa_signal_spectrogram
@section mataa_signal_spectrogram

file: ...mataa_tools/mataa_signal_spectrogram.m@*

function [m,t,f] = mataa_signal_spectrogram (s,t,dt,smooth);@*

DESCRIPTION:@*
Calculate spectrogram (aka sonogram) of the signal s(t).@*

INPUT:@*
s: vector containing the samples values of the signal.@*
t: time values of samples in h (vector, in seconds) or sampling rate of h (scalar, in Hz)@*
dt: width time chunks used to calculate of spectrogram lines@*
smooth (optional): if specified, the data is smoothed in the frequency domain over the octave interval smooth_interval.@*

OUTPUT:@*
m: magnitude values in dB (matrix)@*
t: time values@*
f: frequency values@*

EXAMPLE:@*
fs = 44100; L = 3;@*
[s1,t] = mataa_signal_generator ("sweep_lin",fs,L,[1000 20000]);@*
s2     = mataa_signal_generator ("sweep_log",fs,L,[1000 20000]);@*
s3     = s1+s2;@*
[M1,T1,F1] = mataa_signal_spectrogram (s1,t,0.05);@*
[M2,T2,F2] = mataa_signal_spectrogram (s2,t,0.05);@*
[M3,T3,F3] = mataa_signal_spectrogram (s3,t,0.05);@*
subplot (3,1,1); surf (T1,F1/1000,M1); shading interp; view (0,90); ylabel ('Frequency (kHz)');@*
subplot (3,1,2); surf (T2,F2/1000,M2); shading interp; view (0,90); ylabel ('Frequency (kHz)');@*
subplot (3,1,3); surf (T3,F3/1000,M3); shading interp; view (0,90); xlabel ('Time (s)'); ylabel ('Frequency (kHz)');@*
 @*

@findex mataa_signal_to_TestToneFile
@node mataa_signal_to_TestToneFile
@section mataa_signal_to_TestToneFile

file: ...mataa_tools/mataa_signal_to_TestToneFile.m@*

function pathToFile = mataa_signal_to_TestToneFile (s,pathToFile,zeroTime,fs);@*

DESCRIPTION:@*
Saves the test signals in matrix s to a file on disk (for use with TestTone). Optionally, the signals are  padded with zeroes at the beginning and the end.@*

INPUT:@*
s: the signal samples (in the range of [-1..+1]). In general, s is a matrix with each column corresponding to one data channel, and each row corresponding to a signal frame (i.e. all samples corresponding to the same time step). For single-channel data (i.e. mono signals), s is a column vector. A warning will be printed if s has more columns than rows.@*

pathToFile (optional): the path (including the file name) of the destination file. If not specified, a temporary file will be used. If you want to specify zeroTime and fs, but not pathToFile, use pathToFile = '';@*

zeroTime (optional): duration of 'zero signal' to be padded to the beginning and the end of the signal (in seconds). If not specified, no zeros will be padded to the signal.@*

fs (only if zeroTime is specified): the sample rate of the signal (in Hz). This is required to determine the number of 'zero samples'.@*

OUTPUT:@*
pathToFile: the path (including the file name) of the file to which the data was written.@*

NOTE 1: TestTone assumes that all information regarding the sample rate / time interval in between the samples is handled appropriately. mataa_signal_to_TestToneFile therefore does NOT handle any sample timing information. Only the sample VALUES are written to disk.@*

NOTE 2: the data in s should be padded with zeros at the beginning and the end of the signal to avoid problems with sound-I/O latency. If s does not include zeros at the beginning and the end, use the zeroTime option.@*

check format of input data:@*

@findex mataa_signal_window
@node mataa_signal_window
@section mataa_signal_window

file: ...mataa_tools/mataa_signal_window.m@*

function s = mataa_signal_window (s0,window,par,len);@*

DESCRIPTION:@*
Multiplies the signal s0 by the window function with the name 'window', and returns the result in s.@*
Some window functions rely on a parameter, which can be specified by par (par can be omitted for those functions that don't rely on an extra parameter)@*

The following window functions are available (see e.g. http://en.wikipedia.org/wiki/Window_function for a description of these functions):@*
'rectangular', 'rect', 'nowindow', 'none' : rectangular window (i.e., signal is not changed at all)@*
'gauss': gauss window, whith shape parameter sigma = par (par <= 0.5)@*
'sin', 'cos','sine','cosine': sine / cosine window@*
'hamming', 'hamm': Hamming window@*
'hann': Hann window (cosine window). Note: in anology to the 'Hamming' window, this is often wrongly referred to as 'Hanning'. However, the name relates to a guy called Julius von Hann.@*
'bartlett','bart','triangular': Bartlett (triangular) window.@*
'blackman', 'black': Blackman window@*
'flattop': Flat-top window, using the "SRS shape coefficients" (see https://en.wikipedia.org/wiki/Window_function#Flat_top_window ). This window has broad bandwidth, which makes is useful to maintain sinusoidal amplitudes in spectrum analysers, with the drawback of poor frequency resolution.@*
'kaiser': Kaiser window with parameter alpha = par@*
'bingham': Bingham window with parameter par (par = 0 --> rectangular window, par = 1 --> Hann window).@*

Also, 'half' windows may be used, whereby the second half of the window is used. This is done by appending '_half' to the window name. This is useful, for instance, to attenuate echoes towards the end in an impulse response, while retaining the information at the beginning of the signal.@*

Furthermore, mataa_signal_window can also be used to return the window function itself, see example below.@*

INPUT:@*
s0: vector containing the samples values of the original signal (i.e. the signal that will be windowed).@*
window: name of the window type to be used (string, see above).@*
par: parameter(s) to further specify the window function. Depending on the window type, par may not be required (and will be ignored in these cases).@*
len: fractional length of full-amplitude range inserted between rise / fall of window slopes (optional, default: len = 0)@*

OUTPUT:@*
s: vector containing the sample value of the windowed signal.@*

EXAMPLES:@*

> s = mataa_signal_window(s,'hamming'); % replaces s by a hamming-windowed version of itself@*

> s = mataa_signal_window(s,'hamming_half'); % replaces s by a version of s windowed by the second half of a hamming window@*

> s = mataa_signal_window(repmat(1,1,1000),'gauss',0.4); % returns just the gauss window itself@*


@findex mataa_smooth_log
@node mataa_smooth_log
@section mataa_smooth_log

file: ...mataa_tools/mataa_smooth_log.m@*

function [y,x] = mataa_smooth_log (yRaw,xRaw,step)@*

THIS FUNCTION IS OBSOLETE. USE mataa_FR_smooth instead.@*


@findex mataa_speaker_TSP_addmass
@node mataa_speaker_TSP_addmass
@section mataa_speaker_TSP_addmass

file: ...mataa_tools/mataa_speaker_TSP_addmass.m@*

function [Vas,Cms,Mms,Sd] = mataa_speaker_TSP_addmass (fs,fsM,M,D);@*

DESCRIPTION:@*
Determine Thiele-Small parameters Vas, Cms and Mms using the "added mass method". This works by comparing the resonance frequency of the unmodified driver (fs) with the resonance frequency (fsM) obtained after adding a mass (M) to cone. Make sure the mass M is firmly attached to the cone!@*

INPUT:@*
fs: driver resonance frequency (Hz)@*
fsM: resonance frequency with added mass (Hz)@*
M: added mass (g)@*
D: cone diameter including part of the surround, typically 1/3 to 1/2 the width of the surround (cm)@*

OUTPUT:@*
Vas: driver compliance equivalent volume (litres)@*
Cms: Compliance of the driver's suspension (mm/N)@*
Mms: Mass of the diaphragm/coil, including acoustic load (g)@*
Sd: Projected area of the driver diaphragm (cm²)@*

EXAMPLE (measured driver resonance at fs = 46.1 Hz, fsM = 21.9 Hz with added mass M = 166 g, cone diameter with 1/2 surround on both sides D = 25.0 cm):@*
> [Vas,Cms,Mms,Sd] = mataa_speaker_TSP_addmass (46.1,21.9,166,25.0);@*
 @*

@findex mataa_spectrum_analyser
@node mataa_spectrum_analyser
@section mataa_spectrum_analyser

file: ...mataa_tools/mataa_spectrum_analyser.m@*

function mataa_spectrum_analyser( chan_out, chan_in, fx, fs, N_len, N_avg )@*

Real-time spectrum analyser (PlayRec only). THIS IS WORK IN PROGRESS!!!@*

EXAMPLE:@*
> mataa_spectrum_analyser( 1, 1, 1000.0, 44100, 1024, 5 )@*

@findex mataa_tempfile
@node mataa_tempfile
@section mataa_tempfile

file: ...mataa_tools/mataa_tempfile.m@*

function filepath = mataa_tempfile;@*

DESCRIPTION:@*
returns a path to a tempfile to be used with MATAA@*

INPUT:@*
(none)@*

OUTPUT:@*
filepath: string containing the path to the tempfile (including the file name).@*


@findex mataa_t_to_f0
@node mataa_t_to_f0
@section mataa_t_to_f0

file: ...mataa_tools/mataa_t_to_f0.m@*

function f = mataa_t_to_f0 (t);@*

DESCRIPTION:@*
This function returns the frequency bins of the fourier spectrum of a signal sampled at times t (vector). t must be  be sorted and evenly spaced for this.@*

INPUT:@*
t: time values (vector, in seconds) of the signal@*

OUTPUT:@*
f: vector of the fourier-frequency bins (in Hz)@*


@findex mataa_t_to_f
@node mataa_t_to_f
@section mataa_t_to_f

file: ...mataa_tools/mataa_t_to_f.m@*

function f = mataa_t_to_f (t);@*

DESCRIPTION:@*
Same as mataa_t_to_f0, but the component corresponding to f=0 is removed from the output.@*

INPUT:@*
(see mataa_t_to_f0).@*

OUTPUT:@*
(see mataa_to_f0).@*




@paragraphindent 3